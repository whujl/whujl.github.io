<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[遥远的小村庄]]></title>
  <subtitle><![CDATA[仰望星空，脚踏实地]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-03-31T13:24:41.948Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Jiao Long]]></name>
    <email><![CDATA[whuroger@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <link href="http://yoursite.com/2016/03/31/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2016/03/31/冒泡排序/</id>
    <published>2016-03-31T12:56:16.000Z</published>
    <updated>2016-03-31T13:21:07.000Z</updated>
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2>
<p>设数组长度为N,从小向大排序:</p>
<ol>
<li><p>比较相邻的前后两个数据，如果前面数据大于后面的数据，就将两个数据交换。</p>
</li>
<li><p>这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。</p>
</li>
<li><p>N=N-1，如果N不为0就重复前面二步，否则排序完成。</p>
</li>
</ol>
<h2 id="时间复杂度和稳定性">时间复杂度和稳定性</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<p>冒泡排序的时间复杂度是O(N^2)，假设数组中有N个元素，遍历一趟的时间复杂度是O(N),需要遍历N-1次，因此时间复杂度为O(N^2)。</p>
<h3 id="稳定性">稳定性</h3>
<p>冒泡排序是稳定的排序，如果前后两个元素相等，不会交换前后顺序。</p>
<h2 id="实现">实现</h2>
<h3 id="基本实现">基本实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span>(<span class="keyword">int</span>[] a) {</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) {</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; a.length - i; j++) {</div><div class="line">            <span class="keyword">if</span> (a[j - <span class="number">1</span>] &gt; a[j]) {</div><div class="line">                swap(a, j, j - <span class="number">1</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="优化一：如果没有发生交换则停止排序">优化一：如果没有发生交换则停止排序</h3>
<p>设置一个flag表示这趟是否发生交换，如果交换则为true， 否则为false。这样如果一趟没有发生交换，则说明排序完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span>(<span class="keyword">int</span>[] a){</div><div class="line">    <span class="keyword">int</span> n = a.length;</div><div class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(flag){</div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt; n; i++){</div><div class="line">            <span class="keyword">if</span>(a[i-<span class="number">1</span>] &gt; a[i]){</div><div class="line">                swap(a, i, i-<span class="number">1</span>);</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        n--;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="优化二:_对于只有前面部分无序数组优化">优化二: 对于只有前面部分无序数组优化</h3>
<p>如果对于一个很大的数组，只有前面部分是无序状态，后面都已经有序，那么在一次遍历以后，只需要记录下这个位置，下次遍历只需要遍历前面这部分无序数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span>(<span class="keyword">int</span>[] a) {</div><div class="line">       <span class="keyword">int</span> flag = a.length;</div><div class="line"></div><div class="line">       <span class="keyword">while</span> (flag &gt; <span class="number">0</span>) {</div><div class="line">           <span class="keyword">int</span> k = flag;</div><div class="line">           flag = <span class="number">0</span>;</div><div class="line"></div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k; j++) {</div><div class="line">               <span class="keyword">if</span> (a[j - <span class="number">1</span>] &gt; a[j]) {</div><div class="line">                   swap(a, j, j - <span class="number">1</span>);</div><div class="line">                   flag = j;</div><div class="line">               }</div><div class="line">           }</div><div class="line">       }</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="介绍">介绍</h2>
<p>设数组长度为N,从小向大排序:</p>
<ol>
<li><p>比较相邻的前后两个数据，如果前面数据大于后面的数据，就将两个数据交换。</p>
</li>
<li><p>这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数]]>
    </summary>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ThreadLocal详解]]></title>
    <link href="http://yoursite.com/2016/03/28/ThreadLocal%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/03/28/ThreadLocal详解/</id>
    <published>2016-03-28T09:38:29.000Z</published>
    <updated>2016-03-28T13:53:02.000Z</updated>
    <content type="html"><![CDATA[<p>ThreadLocal用于提供线程局部变量，即通过get()和set()方法访问某个变量的线程都有自己的局部变量。但它是通过各个线程自己创建对象，然后调用set方法设置进去，而不是由ThreadLocal自己来创建变量副本。</p>
<h2 id="存储">存储</h2>
<p>ThreadLocal作为线程局部变量，那么应该就存在Thread对象中，可以从Thread源码中找到线程局部变量存储的地方：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></div><div class="line">    * by the ThreadLocal class. */</div><div class="line">   ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div><div class="line">   </div><div class="line">   <span class="javadoc">/**</span></div><div class="line">    * ThreadLocalMap is a customized hash map suitable only for</div><div class="line">    * maintaining thread local values. No operations are exported</div><div class="line">    * outside of the ThreadLocal class. The class is package private to</div><div class="line">    * allow declaration of fields in class Thread.  To help deal with</div><div class="line">    * very large and long-lived usages, the hash table entries use</div><div class="line">    * WeakReferences for keys. However, since reference queues are not</div><div class="line">    * used, stale entries are guaranteed to be removed only when</div><div class="line">    * the table starts running out of space.</div><div class="line">    */</div><div class="line">   static <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span></span>{</div><div class="line">    	<span class="javadoc">/**</span></div><div class="line">        * The entries in this hash map extend WeakReference, using</div><div class="line">        * its main ref field as the key (which is always a</div><div class="line">        * ThreadLocal object).  Note that null keys (i.e. entry.get()</div><div class="line">        * == null) mean that the key is no longer referenced, so the</div><div class="line">        * entry can be expunged from table.  Such entries are referred to</div><div class="line">        * as "stale entries" in the code that follows.</div><div class="line">        */</div><div class="line">       static <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>{</div><div class="line">           <span class="javadoc">/** The value associated with this ThreadLocal. */</span></div><div class="line">           Object value;</div><div class="line"></div><div class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) {</div><div class="line">               <span class="keyword">super</span>(k); <span class="comment">//将ThreadLocal对象转换为弱引用对象，作为key。</span></div><div class="line">               value = v;</div><div class="line">           }</div><div class="line">       }</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>可以看到ThreadLocal.ThreadLocalMap 是 ThreadLocal 的一个静态内部类,采用定制化的HashMap用来存储线程局部变量，放置于Entry类中，Entry类继承与WeakRefernce<threadlocal<?>&gt;。</threadlocal<?></p>
<p>下面是ThreadLocalMap的构造函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line">      * Construct a new map initially containing (firstKey, firstValue).</div><div class="line">      * ThreadLocalMaps are constructed lazily, so we only create</div><div class="line">      * one when we have at least one entry to put in it.</div><div class="line">      */</div><div class="line">     ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) {</div><div class="line">         table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</div><div class="line">         <span class="keyword">int</span> i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - <span class="number">1</span>);</div><div class="line">         table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</div><div class="line">         size = <span class="number">1</span>;</div><div class="line">         setThreshold(INITIAL_CAPACITY);</div><div class="line">     }</div></pre></td></tr></table></figure>

<p>可以看出ThreadLocalMap是采用一个INITIAL_CAPACITY大小的Entry数组保存ThreadLocao的key-value信息，并且索引是通过firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1)来实现。</p>
<h2 id="set方法">set方法</h2>
<p>下面来看ThreadLocal的set方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(T <span class="keyword">value</span>) {</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            map.<span class="keyword">set</span>(<span class="keyword">this</span>, <span class="keyword">value</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            createMap(t, <span class="keyword">value</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">ThreadLocalMap getMap(Thread t) {</div><div class="line">        <span class="keyword">return</span> t.threadLocals;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> createMap(Thread t, T firstValue) {</div><div class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span>(ThreadLocal&lt;?&gt; key, Object <span class="keyword">value</span>) {</div></pre></td></tr></table></figure>

<p>在往ThreadLocal里设置值得时候先拿到当前线程，接着去获得当前线程的ThreadLocalMap，如果为null，则进行初始化，这里采用了延迟初始化技术。否则就将threadlocal实例-value这种k-v键值对放入map。</p>
<p>接下来查看ThreadLocalMap的set方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span>(ThreadLocal&lt;?&gt; key, Object <span class="keyword">value</span>) {</div><div class="line">            Entry[] tab = table;</div><div class="line">            <span class="keyword">int</span> len = tab.length;</div><div class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode & (len-<span class="number">1</span>);</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (Entry e = tab[i];</div><div class="line">                 e != <span class="keyword">null</span>;</div><div class="line">                 e = tab[i = nextIndex(i, len)]) {</div><div class="line">                ThreadLocal&lt;?&gt; k = e.<span class="keyword">get</span>();</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (k == key) {</div><div class="line">                    e.<span class="keyword">value</span> = <span class="keyword">value</span>;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) {</div><div class="line">                    replaceStaleEntry(key, <span class="keyword">value</span>, i);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">            tab[i] = <span class="keyword">new</span> Entry(key, <span class="keyword">value</span>);</div><div class="line">            <span class="keyword">int</span> sz = ++size;</div><div class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) && sz &gt;= threshold)</div><div class="line">                rehash();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>一个线程中有多少个线程局部对象要保存，那么就初始化多少个 Entry 对象来保存。</p>
<p>每一次在往ThreadLocalMap中添加值的时候都会进行扫描以及资源回收。每一次调用ThreadLocalMap的genEntry函数或者set函数，都可以进行内存回收，但是保证get和set函数一直被调用到是不可能任何情况都成立的，因此所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。</p>
<p>ThreadLocalMap 中 private Entry[] table 的初始大小是16，超过容量的2/3时，会进行rehash和扩容。</p>
<h2 id="get方法">get方法</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> T <span class="title">get</span>() {</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) {</div><div class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) {</div><div class="line">                @SuppressWarnings(<span class="string">"unchecked"</span>)</div><div class="line">                T result = (T)e.<span class="keyword">value</span>;</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> setInitialValue();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> T <span class="title">setInitialValue</span>() {</div><div class="line">        T <span class="keyword">value</span> = initialValue();</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            map.<span class="keyword">set</span>(<span class="keyword">this</span>, <span class="keyword">value</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            createMap(t, <span class="keyword">value</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>调用ThreadLocal的get方法时会先拿到当前线程，并根据当前线程拿到ThreadLocalMap变量，如果map不为空，通过当前threadlocal为key拿到对应的值，并返回。如果map为空，那么去设置初始化的值，这里需要通过复写initialValue()设置初值。如果没有override，会返回null，但是ThreadLocalMap还是进行了初始化。</p>
<h2 id="总结">总结</h2>
<ol>
<li>每个Thread维护一个ThreadLocalMap映射表，这个映射表的key是ThreadLocal实例本身，value是真正需要存储的Object。这样设计之后每个Map的Entry数量变小了:之前是Thread的数量，现在是ThreadLocal的数量，能提高性能。并且当Thread销毁之后对应的ThreadLocalMap也就随之销毁了，能减少内存使用量。</li>
<li>线程死亡时，线程局部变量会自动回收内存；</li>
<li>线程局部变量时通过一个 Entry 保存在map中，该Entry 的key是一个 WeakReference包装的ThreadLocal, value为线程局部变量; key 到 value 的映射是通过：ThreadLocal.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1) 来完成的；</li>
<li>当线程拥有的局部变量超过了容量的2/3(没有扩大容量时是10个)，会涉及到ThreadLocalMap中Entry的回收；</li>
</ol>
<h2 id="参考">参考</h2>
<ol>
<li><a href="http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/index.html" target="_blank" rel="external">http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/index.html</a></li>
<li><a href="http://zhuanlan.zhihu.com/winwill2012/20213204" target="_blank" rel="external">http://zhuanlan.zhihu.com/winwill2012/20213204</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>ThreadLocal用于提供线程局部变量，即通过get()和set()方法访问某个变量的线程都有自己的局部变量。但它是通过各个线程自己创建对象，然后调用set方法设置进去，而不是由ThreadLocal自己来创建变量副本。</p>
<h2 id="存储">存储</h2>
]]>
    </summary>
    
      <category term="JUC" scheme="http://yoursite.com/tags/JUC/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="ThreadLocal" scheme="http://yoursite.com/tags/ThreadLocal/"/>
    
      <category term="JUC源码解析" scheme="http://yoursite.com/categories/JUC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java线程的终止]]></title>
    <link href="http://yoursite.com/2016/03/28/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2/"/>
    <id>http://yoursite.com/2016/03/28/Java线程的终止/</id>
    <published>2016-03-27T17:14:18.000Z</published>
    <updated>2016-03-27T18:19:16.000Z</updated>
    <content type="html"><![CDATA[<p>Java没有提供任何机制来安全地终止线程，因此只有通过一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。</p>
<p>一个可取消的任务必须拥有取消策略，在这个策略中详细地定义取消操作的”How”/“When”/“what”，即其他代码如何请求取消该任务，在何时检查是否已经取消了请求，以及相应取消请求时应该执行哪些操作。</p>
<p>下面介绍几种取消任务的方法：</p>
<h2 id="使用volatile设置已请求取消标志">使用volatile设置已请求取消标志</h2>
<p>这种方式通过设置一个“已请求取消标志”，任务定期地咋查看该flag,如果设置了这个标志，那么任务将提前结束：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeGenerator</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;BigInteger&gt; primes = <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(){</div><div class="line">		BigInteger p = BigInteger.ONE;</div><div class="line">		<span class="keyword">while</span>(!cancelled){</div><div class="line">			p = p.nextProbablePrime();</div><div class="line">			<span class="keyword">synchronized</span>(<span class="keyword">this</span>){</div><div class="line">				primes.add(p);</div><div class="line">			}</div><div class="line">		}</div><div class="line">		</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span>(){</div><div class="line">		<span class="keyword">this</span>.cacelled = <span class="keyword">true</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;BigInteger&gt; <span class="title">get</span>(){</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(primes);</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果这些需要使用生产者消费者，生产者线程生成素数，并将它们放入到一个阻塞队列。如果生产者的速度超过了消费者的处理速度，队列将被填满，put方法也会阻塞。当生产者在put方法中阻塞时，如果消费者希望取消生产者任务，将cancelled设置为true，但是这时生产者还处于阻塞状态，无法检查这个flag，也无法停止生产。</p>
<h2 id="使用中断实现取消">使用中断实现取消</h2>
<p>对于上面介绍这种情况，可以使用中断而不是boolean标志来请求取消。因为每个线程都有一个boolean类型的中断状态，当中断线程时，这个线程的中断状态将被置为true。中断并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的取消点中断自己。</p>
<p>这种中断机制与取消标志位相比，它能够与可阻塞的库函数实现良好交互。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>{</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">PrimeProducer</span>(BlockingQueue&lt;BigInteger queue){</div><div class="line">		<span class="keyword">this</span>.queue = queue;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(){</div><div class="line">		<span class="keyword">try</span>{</div><div class="line">			BigInteger p = BigInteger.ONE;</div><div class="line">			<span class="keyword">while</span>(!Thread.currentThread.isInterrupted()){</div><div class="line">				queue.put(p = p.nextProbablePrime());</div><div class="line">			}<span class="keyword">catch</span>(InterruptedException consumed){</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span>(){</div><div class="line">		interrupt();</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里虽然调用了put方法，put方法会相应中断，因此并不一定需要进行显式的检测。但执行检测却会使PrimeProducer对中断具有更高的相应性，因为它是在启动寻找素数任务之前检查中断的，而不是在任务完成之后。</p>
<p>当调用可中断的阻塞函数时，两种实用策略可用于处理InterruptedException：</p>
<ul>
<li>传递异常，从而使你的方法也称为可中断的阻塞方法。</li>
<li>恢复中断状态，从而使调用栈中的上层代码能够对其进行处理。</li>
</ul>
<h2 id="使用Future实现取消">使用Future实现取消</h2>
<p>Future拥有cancel方法可以取消任务，该方法具有一个boolean类型参数”mayInterrupteIfRunning”，如果为true并且任务正在某个线程中运行，那么这个线程可以被中断。如果这个参数为false,那么意味着“若任务还没有启动，就不要运行它”。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> timedRun(Runnable r, <span class="keyword">long</span> timeout, TimeUnit unit) </div><div class="line">					<span class="keyword">throws</span> InterruptedException{</div><div class="line">	Future&lt;?&gt; <span class="keyword">task</span> = taskExec.submit(r);</div><div class="line">	<span class="keyword">try</span>{</div><div class="line">		<span class="keyword">task</span>.get(timeout, unit);</div><div class="line">	}<span class="keyword">catch</span>(TimeoutException e){</div><div class="line">		<span class="comment">//接下来任务将被取消</span></div><div class="line">	}<span class="keyword">catch</span>(ExecutionException e){</div><div class="line">		<span class="comment">//如果在任务中抛出了异常，那么重新抛出该异常</span></div><div class="line">		<span class="keyword">throw</span> launderThrowable(e.getCause());</div><div class="line">	}<span class="keyword">finally</span>{</div><div class="line">		<span class="comment">//如果任务已经结束，那么执行取消操作也不会带来任何影响。</span></div><div class="line">		<span class="comment">//如果任务正在运行，那么将被中断。</span></div><div class="line">		<span class="keyword">task</span>.cancel(<span class="keyword">true</span>);</div><div class="line">	}</div><div class="line">						</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="采用ThreadPoolExecutor的newTaskFor封装非标准取消">采用ThreadPoolExecutor的newTaskFor封装非标准取消</h2>
<p>当把一个Callable提交给ExecutorService时，submit方法会返回一个Future，我们可以通过这个Future来取消任务。newTaskFor是一个工厂方法，它将创建Future来代表任务。newTaskFor还能返回一个RunnableFuture接口，该接口扩展了Future和Runnable。</p>
<p>通过定制表示任务的Future可以该表Future.cancle()行为，比如可以实现记录日志或者收集取消操作的统计信息。下面的代码介绍了通过newTaskFor将非标准的取消操作封装在一个任务中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CancellableTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt;</span>{</div><div class="line">	<span class="keyword">void</span> cancel();</div><div class="line">	RunnableFuture&lt;T&gt; newTask();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancellingExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span>{</div><div class="line">	<span class="keyword">protected</span>&lt;T&gt; RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span>(Callable&lt;T&gt; callable){</div><div class="line">		<span class="keyword">if</span>(callable <span class="keyword">instanceof</span> CancellableTask){</div><div class="line">			<span class="keyword">return</span> ((CancellableTask&lt;T&gt;) callable).newTask();</div><div class="line">		}<span class="keyword">else</span>{</div><div class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.newTaskFor(callable);</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketUsingTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">CancellableTask</span>&lt;<span class="title">T</span>&gt;</span>{</div><div class="line">	<span class="keyword">private</span> Socket socket;</div><div class="line">	</div><div class="line">	<span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSocket</span>(Socket s){</div><div class="line">		<span class="keyword">this</span>.socket = s;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cancel</span>(){</div><div class="line">		<span class="keyword">try</span>{</div><div class="line">			<span class="keyword">if</span>(socket != <span class="keyword">null</span>){</div><div class="line">				socket.close();</div><div class="line">			}</div><div class="line">		}<span class="keyword">catch</span>(IOException ignored){</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> RunnableFuture&lt;T&gt; <span class="title">newTask</span>(){</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(<span class="keyword">this</span>){</div><div class="line">			<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span>(<span class="keyword">boolean</span> mayInterruptIfRunning){</div><div class="line">				<span class="keyword">try</span>{</div><div class="line">					SocketUsingTask.<span class="keyword">this</span>.cancel():</div><div class="line">				}<span class="keyword">finally</span>{</div><div class="line">					<span class="keyword">return</span> <span class="keyword">super</span>.cancel(mayInterruptIfRunning);</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="使用ExecutorService">使用ExecutorService</h2>
<p>可以使用ExecutorService的shutdown正常关闭和shutdownNow强行关闭。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogService</span></span>{</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = Executors.newSingleThreadExecutor();</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span>(){}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span>() <span class="keyword">throws</span> InterruptedException{</div><div class="line">		<span class="keyword">try</span>{</div><div class="line">			exec.shutdown();</div><div class="line">			exec.awaitTermination(TIMEOUT, UNIT);</div><div class="line">		}<span class="keyword">finally</span>{</div><div class="line">			writer.close();</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span>(String msg){</div><div class="line">		<span class="keyword">try</span>{</div><div class="line">			exec.execute(<span class="keyword">new</span> WriteTask(msg));</div><div class="line">		}<span class="keyword">catch</span>(RejectedExecutionException ignored){</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="使用“毒丸”对象">使用“毒丸”对象</h2>
<p>“毒丸”是指一个放在队列上的对象，当得到这个对象时，立即停止。生产者提交了这个对象以后，将不会提交任何对象。而消费者在得到这个对象时，停止消费。这种方式只有在生产者和消费者的数量都已知的情况下，才可以使用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java没有提供任何机制来安全地终止线程，因此只有通过一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。</p>
<p>一个可取消的任务必须拥有取消策略，在这个策略中详细地定义取消操作的”How”/“When”/“what”，即其他代码如何请求取消该任务，在何]]>
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Unix的I/O模型]]></title>
    <link href="http://yoursite.com/2016/03/26/Unix%E7%9A%84I-O%E6%A8%A1%E5%9E%8B%E4%B8%8EJava%E7%9A%84I-O/"/>
    <id>http://yoursite.com/2016/03/26/Unix的I-O模型与Java的I-O/</id>
    <published>2016-03-26T04:03:25.000Z</published>
    <updated>2016-03-26T11:39:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Unix的I/O模型">Unix的I/O模型</h2>
<p>Unix内核将所有外设都看做文件来操作，对文件的读写操作会调用内核提供的系统命令，返回一个文件描述符(file descriptor)。</p>
<p>Unix提供了以下5种I/O模型：</p>
<h3 id="阻塞I/O模型">阻塞I/O模型</h3>
<p>缺省情况下，所有文件操作都是阻塞的，如下图所示，进程调用recvfrom, 系统调用知道数据报到达并且被复制到应用进程的缓冲区中或发生错误才返回，所以说进程在从调用recvfrom开始到它返回的整段时间内都是阻塞的。包括两个阶段：</p>
<ul>
<li>等待数据就绪。等待将数据(包括磁盘数据或者网络数据)读取到内核态内存中。</li>
<li>数据从内核拷贝到进程。用户态的程序没有权限直接读取内核态内存,因此内核负责把内核态内存中的数据拷贝一份到用户态内存中。</li>
</ul>
<p><img src="/img/IO/阻塞IO.png" alt="image"></p>
<h3 id="非阻塞式I/O模型">非阻塞式I/O模型</h3>
<p>非阻塞式I/O是当锁清秋的I/O操作非得把进程投入睡眠才能完成时，不要将进程睡眠，而是返回一个错误。I/O操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。整个 I/O 请求的过程中，虽然用户线程每次发起 I/O 请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的 CPU 的资源。</p>
<p><img src="/img/IO/非阻塞IO.png" alt="image"></p>
<p>当一个应用进程像这样对一个非阻塞描述字循环调用recvfrom时，我们称之为轮询（polling）。应用进程持续轮询内核，以查看某个操作是否就绪。这么做往往耗费大量CPU时间，不过这种模型偶尔也会遇到，通常是在只专门提供某种功能的系统中才有。</p>
<h3 id="I/O复用模型">I/O复用模型</h3>
<p>I/O复用模型会用到select或者poll函数，进程通过将一个或者多个fd传递给select或poll系统调用，阻塞的是在这两个系统调用中的某一个之上，而不是阻塞在真正的I/O系统调用上，这样select/poll可以帮我们探测多个fd是否处于就绪状态。</p>
<p>select/poll顺序扫描fd是否就绪，而且支持的fd数量有限，因此使用受到了一定制约，linux还提供了一个epoll系统调用，epoll使用基于事件驱动方式代替顺序扫描，因此性能更高，当有fd就绪时，立即回调函数rollback。</p>
<p><img src="/img/IO/IO复用.png" alt="image"></p>
<h3 id="信号I/O驱动模型">信号I/O驱动模型</h3>
<p>该模型使用信号，让内核在描述字就绪时发送SIGIO信号通知我们。我们称这种模型为信号驱动I/O(signal-driven I/O)。</p>
<p><img src="/img/IO/信号驱动IO.png" alt="image"></p>
<p>首先开启套接字的信号驱动式I/O功能，并通过sigaction系统调用安装一个信号处理函数，该系统调用将立即返回(非阻塞)。当数据就绪时，为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主循环函数处理数据。</p>
<h3 id="异步I/O模型">异步I/O模型</h3>
<p>告知内核启动某个操作，并让内核在整个操作完成后通知我们，这种模型与信号驱动模型的主要区别是:</p>
<ul>
<li>信号驱动I/O由内核通知我们何时可以开始一个I/O操作。</li>
<li>异步I/O由内核通知我们I/O操作何时完成。</li>
</ul>
<p><img src="/img/IO/异步IO.png" alt="image"></p>
<h2 id="参考文献">参考文献</h2>
<ol>
<li>UNIX网络编程</li>
<li>Netty权威指南</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Unix的I/O模型">Unix的I/O模型</h2>
<p>Unix内核将所有外设都看做文件来操作，对文件的读写操作会调用内核提供的系统命令，返回一个文件描述符(file descriptor)。</p>
<p>Unix提供了以下5种I/O模型：</p>
<h3]]>
    </summary>
    
      <category term="Unix" scheme="http://yoursite.com/tags/Unix/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何获取一个Java对象占用内存大小]]></title>
    <link href="http://yoursite.com/2016/03/24/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AAJava%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/"/>
    <id>http://yoursite.com/2016/03/24/如何获取一个Java对象占用内存大小/</id>
    <published>2016-03-24T08:38:29.000Z</published>
    <updated>2016-03-24T09:45:20.000Z</updated>
    <content type="html"><![CDATA[<p>这几天在准备面试，把《深入理解Java虚拟机》，《深入分析Java Web》这两本书又翻了一遍，回顾了一些关于JVM内存划分相关的知识，但是对于如何判断Java对象内存大小并没有什么思路，于是在网上找到了一篇神文：<a href="http://www.jroller.com/maxim/entry/again_about_determining_size_of" target="_blank" rel="external">Again about determining size of Java object
</a> ，里面提供了一种采用Java Instrumentation计算Java对象内存大小的方法。</p>
<h2 id="几种不同的计算Java内存大小的方式">几种不同的计算Java内存大小的方式</h2>
<ul>
<li><a href="http://jroller.com/mipsJava/entry/sizeof_java_objects" target="_blank" rel="external">http://jroller.com/mipsJava/entry/sizeof_java_objects</a>提供了一种很巧妙的方法，采用System.gc(),Runtime.freeMemory()和Runtime.totalMemory(), 先创建大量的对象，然后分别比较GC前后heap的大小，就可以计算出每个对象所占内存大小。</li>
<li>估算所有primitive type的大小来估算对象大小。</li>
<li>使用Instrumentation.getObjectSize()方法。</li>
</ul>
<h2 id="使用Instrumentation_API计算内存大小">使用Instrumentation API计算内存大小</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Array;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</div><div class="line"><span class="keyword">import</span> java.util.IdentityHashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SizeOfAgent</span> </span>{</div><div class="line"></div><div class="line">    <span class="keyword">static</span> Instrumentation inst;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span>(String agentArgs, Instrumentation instP) {</div><div class="line">        inst = instP;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line">     * 直接计算当前对象占用空间大小，包括当前类及超类的基本类型实例字段大小、&lt;/br&gt;</div><div class="line">     * 引用类型实例字段引用大小、实例基本类型数组总占用空间、实例引用类型数组引用本身占用空间大小;&lt;/br&gt;</div><div class="line">     * 但是不包括超类继承下来的和当前类声明的实例引用字段的对象本身的大小、实例引用数组引用的对象本身的大小 &lt;/br&gt;</div><div class="line">     * 具体结果和JVM不同实现有关.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sizeOf</span>(Object o) {</div><div class="line">        <span class="keyword">if</span> (inst == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not access instrumentation environment.\n"</span> +</div><div class="line">                    <span class="string">"Please check if jar file containing SizeOfAgent class is \n"</span> +</div><div class="line">                    <span class="string">"specified in the java's \"-javaagent\" command line argument."</span>);</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> inst.getObjectSize(o);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line">     * Calculates full size of object iterating over its hierarchy graph.</div><div class="line">     *<span class="javadoctag"> @param</span> obj object to calculate size of</div><div class="line">     *<span class="javadoctag"> @return</span> object size</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fullSizeOf</span>(Object obj) {</div><div class="line">        Map&lt;Object, Object&gt; visited = <span class="keyword">new</span> IdentityHashMap&lt;Object, Object&gt;();</div><div class="line">        Stack&lt;Object&gt; stack = <span class="keyword">new</span> Stack&lt;Object&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">long</span> result = internalSizeOf(obj, stack, visited);</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</div><div class="line">            result += internalSizeOf(stack.pop(), stack, visited);</div><div class="line">        }</div><div class="line">        visited.clear();</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">skipObject</span>(Object obj, Map&lt;Object, Object&gt; visited) {</div><div class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) {</div><div class="line">            <span class="comment">// skip interned string</span></div><div class="line">            <span class="keyword">if</span> (obj == ((String) obj).intern()) {</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> (obj == <span class="keyword">null</span>) <span class="comment">// skip visited object</span></div><div class="line">                || visited.containsKey(obj);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">internalSizeOf</span>(Object obj, Stack&lt;Object&gt; stack, Map&lt;Object, Object&gt; visited) {</div><div class="line">        <span class="keyword">if</span> (skipObject(obj, visited)) {</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        }</div><div class="line">        visited.put(obj, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</div><div class="line">        <span class="comment">// get size of object + primitive variables + member pointers</span></div><div class="line">        result += SizeOfAgent.sizeOf(obj);</div><div class="line"></div><div class="line">        <span class="comment">// process all array elements</span></div><div class="line">        Class clazz = obj.getClass();</div><div class="line">        <span class="keyword">if</span> (clazz.isArray()) {</div><div class="line">            <span class="keyword">if</span> (clazz.getName().length() != <span class="number">2</span>) {<span class="comment">// skip primitive type array</span></div><div class="line">                <span class="keyword">int</span> length = Array.getLength(obj);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</div><div class="line">                    stack.add(Array.get(obj, i));</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// process all fields of the object</span></div><div class="line">        <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) {</div><div class="line">            Field[] fields = clazz.getDeclaredFields();</div><div class="line">            <span class="keyword">for</span> (Field field : fields) {</div><div class="line">                <span class="keyword">if</span> (!Modifier.isStatic(field.getModifiers())) {</div><div class="line">                    <span class="keyword">if</span> (field.getType().isPrimitive()) {</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    } <span class="keyword">else</span> {</div><div class="line">                        field.setAccessible(<span class="keyword">true</span>);</div><div class="line">                        <span class="keyword">try</span> {</div><div class="line">                            <span class="comment">// objects to be estimated are put to stack</span></div><div class="line">                            Object objectToAdd = field.get(obj);</div><div class="line">                            <span class="keyword">if</span> (objectToAdd != <span class="keyword">null</span>) {</div><div class="line">                                stack.add(objectToAdd);</div><div class="line">                            }</div><div class="line">                        } <span class="keyword">catch</span> (IllegalAccessException ex) {</div><div class="line">                            <span class="keyword">assert</span> <span class="keyword">false</span>;</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">            clazz = clazz.getSuperclass();</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>这几天在准备面试，把《深入理解Java虚拟机》，《深入分析Java Web》这两本书又翻了一遍，回顾了一些关于JVM内存划分相关的知识，但是对于如何判断Java对象内存大小并没有什么思路，于是在网上找到了一篇神文：<a href="http://www.jroller.co]]>
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java内存" scheme="http://yoursite.com/categories/Java%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Least Recently Used(LRU)缓存]]></title>
    <link href="http://yoursite.com/2016/03/24/Least%20Recently%20Used(LRU)%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2016/03/24/Least Recently Used(LRU)缓存/</id>
    <published>2016-03-24T07:38:29.000Z</published>
    <updated>2016-03-24T08:03:05.000Z</updated>
    <content type="html"><![CDATA[<p>LRU是Least Recently Used 的缩写，翻译过来就是“最近最少使用”，LRU缓存就是使用这种原理实现，简单的说就是缓存一定量的数据，当超过设定的阈值时就把一些过期的数据删除掉。可以被用来作为手机通话记录，最近接打的电话再最前面，超过一定数目了就删掉。有两种实现方法：</p>
<h2 id="组合LinkedHashMap">组合LinkedHashMap</h2>
<p>LinkedHashMap实现了顺序存储，默认情况下是按照元素的添加顺序存储，也可以启用按照访问顺序存储,同时它还有一个判断是否删除最老数据的方法，默认是返回false，即不删除数据：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="title">LinkedHashMap</span>(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder){</div><div class="line">     <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">     <span class="keyword">this</span>.accessOrder = accessOrder;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span>(Map.Entry&lt;K,V&gt; eldest) {</div><div class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们可以直接组合LinkedHashMap，调用构造器时将accessOrder设置为true，也就是按照访问顺序存储，同时override removeEldestEntry方法使其返回true，就可以非常方便的就可以实现这个数据结构。下面是实现代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CACHE_SIZE;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75</span>f;</div><div class="line">    <span class="keyword">private</span> LinkedHashMap&lt;K, V&gt; map;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">LRUCache</span>(<span class="keyword">int</span> maxCacheSize) {</div><div class="line">        <span class="keyword">this</span>.MAX_CACHE_SIZE = maxCacheSize;</div><div class="line">        <span class="keyword">int</span> capacity = (<span class="keyword">int</span>) Math.ceil(MAX_CACHE_SIZE / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>;</div><div class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(capacity, DEFAULT_LOAD_FACTOR, <span class="keyword">true</span>) {</div><div class="line">            <span class="annotation">@Override</span></div><div class="line">            <span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span>(Entry eldest) {</div><div class="line">                <span class="keyword">return</span> size() &gt; MAX_CACHE_SIZE;</div><div class="line">            }</div><div class="line">        };</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(K key, V value) {</div><div class="line">        map.put(key, value);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> V <span class="title">get</span>(K key) {</div><div class="line">        <span class="keyword">return</span> map.get(key);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>(K key) {</div><div class="line">        map.remove(key);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Set&lt;Entry&lt;K, V&gt;&gt; <span class="title">getAll</span>() {</div><div class="line">        <span class="keyword">return</span> map.entrySet();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>() {</div><div class="line">        <span class="keyword">return</span> map.size();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span>() {</div><div class="line">        map.clear();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> String <span class="title">toString</span>() {</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span> (Map.Entry entry : map.entrySet()) {</div><div class="line">            sb.append(String.format(<span class="string">"%s:%s "</span>, entry.getKey(), entry.getValue()));</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="HashMap加上链表实现">HashMap加上链表实现</h2>
<p>HashMap可以实现get()方法的O(1)时间复杂度，添加和删除需要维护一条双向链表来记录节点顺序同时也可以达到O(1)时间复杂度。</p>
<p><img src="/img/LRUCache.png" alt="image"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> LRUCache {</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> HashMap&lt;Integer, DoubleLinkedNode&gt; nodeMap;</div><div class="line">    <span class="keyword">private</span> DoubleLinkedNode head;</div><div class="line">    <span class="keyword">private</span> DoubleLinkedNode end;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">LRUCache</span>(<span class="keyword">int</span> capacity) {</div><div class="line">        nodeMap = <span class="keyword">new</span> HashMap&lt;&gt;(capacity);</div><div class="line">        <span class="keyword">this</span>.capacity = capacity;</div><div class="line">        <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span>(<span class="keyword">int</span> key) {</div><div class="line">        DoubleLinkedNode node = nodeMap.<span class="keyword">get</span>(key);</div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) {</div><div class="line">            moveToHead(node);</div><div class="line">            <span class="keyword">return</span> node.<span class="keyword">value</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> <span class="keyword">value</span>) {</div><div class="line">        <span class="keyword">if</span> (nodeMap.containsKey(key)) {</div><div class="line">            DoubleLinkedNode node = nodeMap.<span class="keyword">get</span>(key);</div><div class="line">            node.<span class="keyword">value</span> = <span class="keyword">value</span>;</div><div class="line">            moveToHead(node);</div><div class="line">            nodeMap.put(key, node);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            DoubleLinkedNode newNode = <span class="keyword">new</span> DoubleLinkedNode(key, <span class="keyword">value</span>);</div><div class="line">            <span class="keyword">if</span> (capacity &lt;= length) {</div><div class="line">                removeEnd();</div><div class="line">                length--;</div><div class="line">            }</div><div class="line">            nodeMap.put(key, newNode);</div><div class="line">            moveToHead(newNode);</div><div class="line">            length++;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeEnd</span>() {</div><div class="line">        <span class="keyword">if</span>(end != <span class="keyword">null</span>){</div><div class="line">            <span class="keyword">if</span>(end.pre != <span class="keyword">null</span>){</div><div class="line">                end.pre.next = <span class="keyword">null</span>;</div><div class="line">            }<span class="keyword">else</span>{</div><div class="line">                head = <span class="keyword">null</span>;</div><div class="line">            }</div><div class="line">            nodeMap.remove(end.key);</div><div class="line">            end = end.pre;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span>(DoubleLinkedNode node) {</div><div class="line">        <span class="keyword">if</span>(node == head){</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span>(node.pre != <span class="keyword">null</span>){</div><div class="line">            node.pre.next = node.next;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span>(node.next != <span class="keyword">null</span>){</div><div class="line">            node.next.pre = node.pre;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span>(end == node){</div><div class="line">           end = node.pre;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span>(head != <span class="keyword">null</span>){</div><div class="line">            node.next = head;</div><div class="line">            head.pre = node;</div><div class="line">        }</div><div class="line">        head = node;</div><div class="line">        node.pre = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(end == <span class="keyword">null</span>){</div><div class="line">            end = head;</div><div class="line">    	}</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">class</span> DoubleLinkedNode {</div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> key;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">value</span>;</div><div class="line">        <span class="keyword">public</span> DoubleLinkedNode pre;</div><div class="line">        <span class="keyword">public</span> DoubleLinkedNode next;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="title">DoubleLinkedNode</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> <span class="keyword">value</span>) {</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Guava_Cache">Guava Cache</h2>
<p>如果在工作中还是不推荐这种造轮子方式，Guava已经为我们提供了强大的Cache功能，支持如果缓存中已经存在就直接返回，否则按照构造方式获取这个值，并放入到缓存中。并且Guava提供了Callable callback方式创建。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>LRU是Least Recently Used 的缩写，翻译过来就是“最近最少使用”，LRU缓存就是使用这种原理实现，简单的说就是缓存一定量的数据，当超过设定的阈值时就把一些过期的数据删除掉。可以被用来作为手机通话记录，最近接打的电话再最前面，超过一定数目了就删掉。有两种实]]>
    </summary>
    
      <category term="LRU" scheme="http://yoursite.com/tags/LRU/"/>
    
      <category term="Cache" scheme="http://yoursite.com/tags/Cache/"/>
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java泛型擦除与Synthetic方法]]></title>
    <link href="http://yoursite.com/2016/03/23/Java%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4%E4%B8%8Esynthetic%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/03/23/Java泛型擦除与synthetic方法/</id>
    <published>2016-03-23T06:38:29.000Z</published>
    <updated>2016-03-23T06:35:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Java泛型擦除">Java泛型擦除</h2>
<p>关于Java泛型与C++泛型比较这里不再讨论，直接来看Java例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> GenericDemo&lt;T&gt; {</div><div class="line">    <span class="keyword">private</span> T <span class="keyword">value</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">public</span> T <span class="title">getValue</span>() {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(T <span class="keyword">value</span>) {</div><div class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面是经过javap -c -p GenericDemo.class 反编译以后的文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> generic.GenericDemo&lt;T&gt; {</div><div class="line">  <span class="keyword">private</span> T <span class="keyword">value</span>;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> generic.<span class="title">GenericDemo</span>();</div><div class="line">    Code:</div><div class="line">       <span class="number">0</span>: aload_0       </div><div class="line">       <span class="number">1</span>: invokespecial <span class="preprocessor">#1                  // Method java/lang/Object."&lt;init&gt;":()V</span></div><div class="line">       <span class="number">4</span>: <span class="keyword">return</span>        </div><div class="line"></div><div class="line">  <span class="keyword">public</span> T <span class="title">getValue</span>();</div><div class="line">    Code:</div><div class="line">       <span class="number">0</span>: aload_0       </div><div class="line">       <span class="number">1</span>: getfield      <span class="preprocessor">#2                  // Field value:Ljava/lang/Object;</span></div><div class="line">       <span class="number">4</span>: areturn       </div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(T);</div><div class="line">    Code:</div><div class="line">       <span class="number">0</span>: aload_0       </div><div class="line">       <span class="number">1</span>: aload_1       </div><div class="line">       <span class="number">2</span>: putfield      <span class="preprocessor">#2                  // Field value:Ljava/lang/Object;</span></div><div class="line">       <span class="number">5</span>: <span class="keyword">return</span>        </div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看出javac已经将value的类型T编译为了Object类型。</p>
<h2 id="Synthetic方法与方法Override">Synthetic方法与方法Override</h2>
<p>我们为上文中的GenericDemo写一个子类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">GenericDemo</span>&lt;<span class="title">String</span>&gt; </span>{</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String value;</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> String <span class="title">getValue</span>() {</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(String value) {</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>子类A override了父类的getValue()与setValue()方法，那么问题来了，子类的setValue(String value)的参数类型为String， 而父类经过泛型擦除以后为Object，参数类型不同又为何可以override。</p>
<p>这里再提一个问题，A.class.getDeclaredMethods()有几个？</p>
<p>根据Jdk对于getDeclaredMethods()文档，getDeclaredMethods()是不包括继承的方法的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Returns an <span class="keyword">array</span> containing Method objects reflecting all the declared methods <span class="keyword">of</span> the <span class="keyword">class</span> <span class="keyword">or</span> <span class="keyword">interface</span> represented by this <span class="keyword">Class</span> <span class="keyword">object</span>, including <span class="keyword">public</span>, <span class="keyword">protected</span>, <span class="keyword">default</span> (package) access, <span class="keyword">and</span> <span class="keyword">private</span> methods, but excluding <span class="keyword">inherited</span> methods.</div></pre></td></tr></table></figure>

<p>那么这里应该返回2才对，但实际却返回了4:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> java.lang.Object generic.A.<span class="title">getValue</span>() <span class="keyword">is</span> synthetic : <span class="keyword">true</span></div><div class="line"><span class="keyword">public</span> java.lang.String generic.A.<span class="title">getValue</span>() <span class="keyword">is</span> synthetic : <span class="keyword">false</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> generic.A.<span class="title">setValue</span>(java.lang.String) <span class="keyword">is</span> synthetic : <span class="keyword">false</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> generic.A.<span class="title">setValue</span>(java.lang.Object) <span class="keyword">is</span> synthetic : <span class="keyword">true</span></div></pre></td></tr></table></figure>

<p>可以看出这里多了个两个方法，并且我多打印了一个属性synthetic。synthetic意思是合成的，这里为什么会多生成两个get和set方法?还是回到泛型中来，因为要实现override，这时编译器自动生成了两个方法来进行类型转换，下面是反编译后代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(java.lang.String);</div><div class="line">  Code:</div><div class="line">     <span class="number">0</span>: aload_0       </div><div class="line">     <span class="number">1</span>: aload_1       </div><div class="line">     <span class="number">2</span>: putfield      <span class="preprocessor">#2                  // Field value:Ljava/lang/String;</span></div><div class="line">     <span class="number">5</span>: <span class="keyword">return</span>    </div><div class="line"> </div><div class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(java.lang.Object);</div><div class="line">  Code:</div><div class="line">     <span class="number">0</span>: aload_0       </div><div class="line">     <span class="number">1</span>: aload_1       </div><div class="line">     <span class="number">2</span>: checkcast     <span class="preprocessor">#15                 // class java/lang/String</span></div><div class="line">     <span class="number">5</span>: invokevirtual <span class="preprocessor">#16                 // Method setValue:(Ljava/lang/String;)V</span></div><div class="line">     <span class="number">8</span>: <span class="keyword">return</span></div></pre></td></tr></table></figure>

<p>可以看到第二个setValue(Object)方法，先将object转换为String, 然后再去调用setValue(String)方法。</p>
<p>关于Synthetic方法，更多的可以参考：<a href="http://stackoverflow.com/questions/289731/what-java-lang-reflect-method-isbridge-used-for" target="_blank" rel="external">http://stackoverflow.com/questions/289731/what-java-lang-reflect-method-isbridge-used-for</a></p>
<h2 id="Synthetic方法与继承">Synthetic方法与继承</h2>
<p>关于Synthetic方法，并不一定是只在泛型擦除时候出现,来看下面一种情况：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class <span class="type">Parent</span> {</div><div class="line">    <span class="type">void</span> <span class="keyword">method</span>(){}</div><div class="line">}</div><div class="line"></div><div class="line">public class <span class="type">Son</span> extends <span class="type">Parent</span> {</div><div class="line">    public <span class="type">void</span> methodB(){</div><div class="line">        super.<span class="keyword">method</span>();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>有一个包级别可见的类Parent，子类Son继承父类，并作为代理将父类提供给外界使用，这时查看Son的binary code:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Compiled from <span class="string">"Son.java"</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">generic</span>.<span class="title">Son</span> <span class="keyword">extends</span> <span class="title">generic</span>.<span class="title">Parent</span> </span>{</div><div class="line">  <span class="keyword">public</span> generic.<span class="title">Son</span>();</div><div class="line">    Code:</div><div class="line">       <span class="number">0</span>: aload_0       </div><div class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method generic/Parent."&lt;init&gt;":()V</span></div><div class="line">       <span class="number">4</span>: <span class="keyword">return</span>        </div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span>();</div><div class="line">    Code:</div><div class="line">       <span class="number">0</span>: aload_0       </div><div class="line">       <span class="number">1</span>: invokespecial #<span class="number">2</span>                  <span class="comment">// Method generic/Parent.method:()V</span></div><div class="line">       <span class="number">4</span>: <span class="keyword">return</span>        </div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span>();</div><div class="line">    Code:</div><div class="line">       <span class="number">0</span>: aload_0       </div><div class="line">       <span class="number">1</span>: invokespecial #<span class="number">2</span>                  <span class="comment">// Method generic/Parent.method:()V</span></div><div class="line">       <span class="number">4</span>: <span class="keyword">return</span>        </div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到method方法也在Son中被生成了，这也是一个Synthetic方法。</p>
<h2 id="Synthetic方法与AOP">Synthetic方法与AOP</h2>
<p>有使用过Guice作为DI容器，以及进行AOP时候，会发现Guice有时会抛出warning:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">The</span> <span class="keyword">method</span> may be intercepted twice.</div></pre></td></tr></table></figure>

<p>这就是由于Synthetic方法导致的，应该是Guice的一个bug。一种解决方案就是在绑定intercepter时候配置一个相应的Matcher:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NoSyntheticMethodMatcher</span> <span class="keyword">extends</span> <span class="title">AbstractMatcher</span>&lt;<span class="title">Method</span>&gt; </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> NoSyntheticMethodMatcher INSTANCE = <span class="keyword">new</span> NoSyntheticMethodMatcher();</div><div class="line">    <span class="keyword">private</span> <span class="title">NoSyntheticMethodMatcher</span>() {}</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span>(Method method) {</div><div class="line">        <span class="keyword">return</span> !method.isSynthetic();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>只有不是synthetic的方法才进行拦截。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Java泛型擦除">Java泛型擦除</h2>
<p>关于Java泛型与C++泛型比较这里不再讨论，直接来看Java例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div ]]>
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JUC锁概览]]></title>
    <link href="http://yoursite.com/2016/03/22/JUC%E9%94%81%E6%A6%82%E8%A7%88/"/>
    <id>http://yoursite.com/2016/03/22/JUC锁概览/</id>
    <published>2016-03-22T09:38:29.000Z</published>
    <updated>2016-03-22T09:42:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="JUC包中锁的类图">JUC包中锁的类图</h2>
<p><img src="/img/Lock.jpg" alt="alt Lock类图"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="JUC包中锁的类图">JUC包中锁的类图</h2>
<p><img src="/img/Lock.jpg" alt="alt Lock类图"></p>
]]>
    </summary>
    
      <category term="JUC" scheme="http://yoursite.com/tags/JUC/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Lock" scheme="http://yoursite.com/tags/Lock/"/>
    
      <category term="JUC源码解析" scheme="http://yoursite.com/categories/JUC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LockSupport类解析]]></title>
    <link href="http://yoursite.com/2016/03/22/LockSupport%E7%B1%BB%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/03/22/LockSupport类解析/</id>
    <published>2016-03-22T09:25:15.000Z</published>
    <updated>2016-03-22T09:25:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="LockSupport介绍">LockSupport介绍</h2>
<p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语，它可以在线程内任意位置让线程阻塞。</p>
<ul>
<li>和Thread.suspend()相比，它避免了有可能产生的死锁问题。</li>
<li>和Object.wait()相比，它不需要获得对象锁，也不会抛出InterruptedException。</li>
</ul>
<h2 id="Thread的suspend和resume方法">Thread的suspend和resume方法</h2>
<p>Thread类提供了suspend和resume方法挂起与继续执行线程，看上去这对操作非常又用，但却又被标记为deprecated，不推介使用，这是为什么呢？</p>
<p>先来阅读Jdk doc：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="type">This</span> <span class="keyword">method</span> has been deprecated, <span class="keyword">as</span> it <span class="keyword">is</span> inherently deadlock-prone. <span class="type">If</span> the target</div><div class="line">thread holds a lock on the monitor protecting a critical system resource <span class="keyword">when</span> it <span class="keyword">is</span></div><div class="line">suspended, no thread can access this resource until the target thread <span class="keyword">is</span> resumed.</div><div class="line"><span class="type">If</span> the thread that would resume the target thread attempts to lock this monitor</div><div class="line">prior to calling resume, deadlock results. <span class="type">Such</span> deadlocks typically manifest</div><div class="line">themselves <span class="keyword">as</span> <span class="string">"frozen"</span> processes.</div></pre></td></tr></table></figure>

<p>因为这对操作容易产生死锁，在suspend调用后，并不会释放锁资源，其他任何线程都无法访问锁直至这个线程被回复。但是，如果resume操作优先于suspend被执行，那么被挂起的线程就不会再被恢复，锁占有的锁也不会释放，从而导致死锁。</p>
<p>我们通过一段代码来展示这种情况:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspendDemo</span></span>{</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object u = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspendDemoThread</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">Thread</span></span>{</div><div class="line"></div><div class="line">        <span class="keyword">public</span> SuspendDemoThread(String name) {</div><div class="line">            <span class="keyword">super</span>(name);</div><div class="line">        }</div><div class="line"></div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> run() {</div><div class="line">            synchronized (u){</div><div class="line">                System.out.println(<span class="string">"Thread : "</span> + <span class="keyword">this</span>.getName() + <span class="string">" is running!"</span>);</div><div class="line">                suspend();</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws InterruptedException {</div><div class="line">        <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> SuspendDemoThread(<span class="string">"t1"</span>);</div><div class="line">        <span class="keyword">final</span> Thread t2 = <span class="keyword">new</span> SuspendDemoThread(<span class="string">"t2"</span>);</div><div class="line"></div><div class="line">        t1.start();</div><div class="line">        Thread.sleep(<span class="number">100</span>);</div><div class="line">        t2.start();</div><div class="line">        t1.resume();</div><div class="line">        t2.resume();</div><div class="line">        t1.join();</div><div class="line">        t2.join();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在IDE里运行这段代码，有可能导致线程被挂起，这时我们通过jstack查看线程情况：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="string">"t2"</span> <span class="comment">#11 prio=5 os_prio=31 tid=0x00007f9d34048800 nid=0x5103 runnable [0x000070000134f000]</span></div><div class="line">   java.lang.Thread.State: RUNNABLE</div><div class="line">	<span class="keyword">at</span> java.lang.Thread.suspend0(Native Method)</div><div class="line">	<span class="keyword">at</span> java.lang.Thread.suspend(Thread.java:<span class="number">1029</span>)</div><div class="line">	<span class="keyword">at</span> thread.SuspendDemo$ChangeObjectThread.run(SuspendDemo.java:<span class="number">20</span>)</div><div class="line">	- locked &lt;<span class="number">0x00000007957b6f98</span>&gt; (<span class="operator">a</span> java.lang.Object)</div><div class="line">	</div><div class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=31 tid=0x00007fe841011000 nid=0x1703 in Object.wait() [0x0000700000218000]</span></div><div class="line">   java.lang.Thread.State: WAITING (<span class="command"><span class="keyword">on</span> <span class="title">object</span> <span class="title">monitor</span>)</span></div><div class="line">	<span class="keyword">at</span> java.lang.Object.<span class="built_in">wait</span>(Native Method)</div><div class="line">	- waiting <span class="command"><span class="keyword">on</span> &lt;<span class="title">0x00000007957bdf98</span>&gt; (<span class="title">a</span> <span class="title">thread</span>.<span class="title">SuspendDemo</span>$<span class="title">SuspendDemoThread</span>)</span></div><div class="line">	<span class="keyword">at</span> java.lang.Thread.join(Thread.java:<span class="number">1245</span>)</div><div class="line">	- locked &lt;<span class="number">0x00000007957bdf98</span>&gt; (<span class="operator">a</span> thread.SuspendDemo$SuspendDemoThread)</div><div class="line">	<span class="keyword">at</span> java.lang.Thread.join(Thread.java:<span class="number">1319</span>)</div><div class="line">	<span class="keyword">at</span> thread.SuspendDemo.main(SuspendDemo.java:<span class="number">37</span>)</div><div class="line">	<span class="keyword">at</span> sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">	<span class="keyword">at</span> sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</div><div class="line">	<span class="keyword">at</span> sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</div><div class="line">	<span class="keyword">at</span> java.lang.reflect.Method.invoke(Method.java:<span class="number">497</span>)</div><div class="line">	<span class="keyword">at</span> com.intellij.rt.execution.application.AppMain.main(AppMain.java:<span class="number">144</span>)</div></pre></td></tr></table></figure>

<p>发现t2处于runnable状态，而不是waiting状态，并且占有了对象锁,而这时主线程main在等待t2结束，这不利于我们判断问题发生原因。</p>
<h2 id="LockSupport阻塞操作">LockSupport阻塞操作</h2>
<p>下面我们使用LockSupport来重写上面的程序:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspendDemo</span> </span>{</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object u = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspendDemoThread</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">Thread</span></span>{</div><div class="line"></div><div class="line">        <span class="keyword">public</span> SuspendDemoThread(String name) {</div><div class="line">            <span class="keyword">super</span>(name);</div><div class="line">        }</div><div class="line"></div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> run() {</div><div class="line">            synchronized (u){</div><div class="line">                System.out.println(<span class="string">"Thread : "</span> + <span class="keyword">this</span>.getName() + <span class="string">" is running!"</span>);</div><div class="line">                LockSupport.park();</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws InterruptedException {</div><div class="line">        <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> SuspendDemoThread(<span class="string">"t1"</span>);</div><div class="line">        <span class="keyword">final</span> Thread t2 = <span class="keyword">new</span> SuspendDemoThread(<span class="string">"t2"</span>);</div><div class="line"></div><div class="line">        t1.start();</div><div class="line">        Thread.sleep(<span class="number">100</span>);</div><div class="line">        t2.start();</div><div class="line">        LockSupport.unpark(t1);</div><div class="line">        LockSupport.unpark(t2);</div><div class="line">        t1.join();</div><div class="line">        t2.join();</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>将suspend和resume替换为park与unpark，这时发现这段代码一直都可以正常借宿，不会导致线程被永久挂起。这是因为LockSupport类采用类似于信号量的机制，它为每一个线程准备了一个许可，如果这个许可可用，那么park()方法会立即返回，并且消费这个许可；如果这个许可不可用，就会阻塞。而unpark()则使得一个许可变为可用。这样使得，即使unpark()操作发生在park()之前，它也可以使下一次的park()操作立刻返回。因此不会像suspend和resume这样导致线程挂起。</p>
<p>调用park()方法会使得线程处于waiting状态。</p>
<h2 id="LockSupport函数列表">LockSupport函数列表</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回提供给最近一次尚未解除阻塞的 park 方法调用的 blocker 对象，如果该调用不受阻塞，则返回 null。</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">Object</span> getBlocker(Thread t)</div><div class="line"><span class="comment">// 为了线程调度，禁用当前线程，除非许可可用。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> park()</div><div class="line"><span class="comment">// 为了线程调度，在许可可用之前禁用当前线程。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> park(<span class="built_in">Object</span> blocker)</div><div class="line"><span class="comment">// 为了线程调度禁用当前线程，最多等待指定的等待时间，除非许可可用。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> parkNanos(<span class="keyword">long</span> nanos)</div><div class="line"><span class="comment">// 为了线程调度，在许可可用前禁用当前线程，并最多等待指定的等待时间。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> parkNanos(<span class="built_in">Object</span> blocker, <span class="keyword">long</span> nanos)</div><div class="line"><span class="comment">// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> parkUntil(<span class="keyword">long</span> deadline)</div><div class="line"><span class="comment">// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> parkUntil(<span class="built_in">Object</span> blocker, <span class="keyword">long</span> deadline)</div><div class="line"><span class="comment">// 如果给定线程的许可尚不可用，则使其可用。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> unpark(Thread thread)</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="LockSupport介绍">LockSupport介绍</h2>
<p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语，它可以在线程内任意位置让线程阻塞。</p>
<ul>
<li>和Thread.suspend()相比，它避免了有可能产生的死]]>
    </summary>
    
      <category term="Java，JUC" scheme="http://yoursite.com/tags/Java%EF%BC%8CJUC/"/>
    
      <category term="JUC源码分析" scheme="http://yoursite.com/categories/JUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JUC源码解析-基于JDK1.8]]></title>
    <link href="http://yoursite.com/2016/03/22/JUC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%9F%BA%E4%BA%8EJDK1-8/"/>
    <id>http://yoursite.com/2016/03/22/JUC源码解析-基于JDK1-8/</id>
    <published>2016-03-21T17:03:19.000Z</published>
    <updated>2016-03-21T17:03:19.000Z</updated>
    <content type="html"><![CDATA[<p>一直都想写点什么，也算是对自己工作学习的记录与反思，也算是为了未来心仪工作的一点准备，却又一直不知道写点什么。</p>
<p>最近一直在看JDK的源码，发现网上大部分的都是基于1.5或者1.6，Oracle已经正式发布JDK1.8，因此决定基于1.8版本来写点JDK源码分析，包括Collection相关类和JUC包。</p>
<p>本文是关于JUC源码解析的目录：</p>
<p><a href="http://whujl.github.io/2016/03/22/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">1. ReentrantLock源码解析</a></p>
<p>未完待续…</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一直都想写点什么，也算是对自己工作学习的记录与反思，也算是为了未来心仪工作的一点准备，却又一直不知道写点什么。</p>
<p>最近一直在看JDK的源码，发现网上大部分的都是基于1.5或者1.6，Oracle已经正式发布JDK1.8，因此决定基于1.8版本来写点JDK源码分析]]>
    </summary>
    
      <category term="Java，JUC，源码" scheme="http://yoursite.com/tags/Java%EF%BC%8CJUC%EF%BC%8C%E6%BA%90%E7%A0%81/"/>
    
      <category term="JUC源码分析" scheme="http://yoursite.com/categories/JUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ReentrantLock源码解析]]></title>
    <link href="http://yoursite.com/2016/03/22/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/03/22/ReentrantLock源码解析/</id>
    <published>2016-03-21T16:39:03.000Z</published>
    <updated>2016-03-21T16:39:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>对于ReentrantLock,通常是这么使用它的：</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="keyword">try</span>{</div><div class="line">	lock.lock();</div><div class="line">	dosomething();</div><div class="line">}<span class="keyword">finally</span>{</div><div class="line">	lock.unlock();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>ReentrantLock会保证 do something在同一时间只有一个线程在执行这段代码，或者说，同一时刻只有一个线程的lock方法会返回。其余线程会被挂起，直到获取锁。从这里可以看出，其实ReentrantLock实现的就是一个独占锁的功能：有且只有一个线程获取到锁，其余线程全部挂起，直到该拥有锁的线程释放锁，被挂起的线程被唤醒重新开始竞争锁。</p>
<p>那么我们先从lock方法看起：</p>
<h2 id="lock方法">lock方法</h2>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span>() {</div><div class="line">	sync.lock();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>而sync对象是在构造器中初始化，这里ReentrantLock提供了两种不同的实现方式：</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="title">ReentrantLock</span>() {</div><div class="line">	sync = <span class="keyword">new</span> NonfairSync();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="title">ReentrantLock</span>(<span class="keyword">boolean</span> fair) {</div><div class="line">	sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>从字面上可以看出是分为公平锁和非公平锁，默认构造器是非公平锁。</p>
<ul>
<li>公平锁：每个线程抢占锁的顺序为先后调用lock方法的顺序依次获取锁。</li>
<li>非公平锁：每个线程抢占锁的顺序不定，谁运气好，谁就获取到锁，和调用lock方法的先后顺序无关。</li>
</ul>
<p>先看公平锁的lock方法实现：</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">void</span> lock() {</div><div class="line">	acquire(<span class="number">1</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为FairSync以及NonFairSync都继承与AbstractQueuedSynchronizer(本文简称AQS)，这里acquire方法直接调用了AQS的实现。</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span>(<span class="keyword">int</span> arg) {</div><div class="line">	<span class="keyword">if</span> (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">		selfInterrupt();</div><div class="line">   }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>继续查看tryAcquire方法：</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span>(<span class="keyword">int</span> acquires) {</div><div class="line">	<span class="keyword">final</span> Thread current = Thread.currentThread();<span class="comment">//获取当前线程</span></div><div class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">//获取volatile状态位</span></div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) { </div><div class="line">	    <span class="keyword">if</span> (!hasQueuedPredecessors() && compareAndSetState(<span class="number">0</span>, acquires)) {</div><div class="line">	    <span class="comment">//如果队列中没有其他线程,也就说明没有其他线程占有锁。</span></div><div class="line">	    <span class="comment">//并且通过CAS方法修改状态位为1成功，acquires是在lock方法中传来的1.</span></div><div class="line">			setExclusiveOwnerThread(current);<span class="comment">//设置当前线程拥有锁。</span></div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">    }<span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</div><div class="line">    <span class="comment">//如果c不等于0，说明有线程持有锁，而ReentrantLock是可重入锁，因此当前线程可以再次lock。</span></div><div class="line">		<span class="keyword">int</span> nextc = c + acquires;</div><div class="line">       	<span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">       	setState(nextc);<span class="comment">//将状态位加1</span></div><div class="line">       	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"> 	}</div><div class="line"> 	<span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//如果获得锁成功返回true, 否则false</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果tryAcquire(1)没有获得锁，返回false, 那么接着执行acquireQueued(Node.EXCLUSIVE)方法，这里根据方法名称猜测这个方法似乎是将当前线程放入一个队列中去(达到了阻塞目的)。</p>
<p>先查看Node对象属性以及这个EXCLUSIVE含义：</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> class Node {</div><div class="line">	<span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();<span class="comment">//指定这个Node类型为共享类型</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;<span class="comment">//Node为独占类型</span></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</div><div class="line">    <span class="keyword">volatile</span> Node prev;</div><div class="line">    <span class="keyword">volatile</span> Node next;</div><div class="line">    <span class="keyword">volatile</span> Thread thread;<span class="comment">//对应的线程</span></div><div class="line">    Node nextWaiter;</div><div class="line">    Node(Thread thread, Node mode) {            </div><div class="line">    	<span class="keyword">this</span>.nextWaiter = mode;</div><div class="line">        <span class="keyword">this</span>.thread = thread;</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>那么说明addWaiter(Node.EXCLUSIVE)方法是添加独占类型节点，因为ReentrantLock是独占锁。在AQS中维护了一个队列，每次有线程竞争锁失败，都是添加到队列尾部。</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Node <span class="title">addWaiter</span>(Node mode) {</div><div class="line">	<span class="comment">//创建一个包含当前线程的Node，并且为独占类型</span></div><div class="line">	Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</div><div class="line">	Node pred = tail;</div><div class="line">	<span class="keyword">if</span> (pred != <span class="keyword">null</span>) { <span class="comment">//如果队列不为空</span></div><div class="line">		node.prev = pred;</div><div class="line">		<span class="keyword">if</span> (compareAndSetTail(pred, node)) { <span class="comment">//通过CAS方式将队列尾节点设置为这个node</span></div><div class="line">        	pred.next = node;</div><div class="line">        	<span class="keyword">return</span> node;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	enq(node);<span class="comment">//如果队列为空或者CAS方式添加节点失败,通过自旋方式添加。</span></div><div class="line">	<span class="keyword">return</span> node;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>回来看acquireQueued方法：</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> acquireQueued(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg) {</div><div class="line">	<span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">try</span> {</div><div class="line">		<span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">		<span class="keyword">for</span> (;;) {</div><div class="line">			<span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">			<span class="keyword">if</span> (p == head && tryAcquire(arg)) {<span class="comment">//如果当前的节点是head说明他是队列中第一个“有效的”节点，尝试获取锁。</span></div><div class="line">				setHead(node);    </div><div class="line">				p.next = <span class="keyword">null</span>;</div><div class="line">				failed = <span class="keyword">false</span>;</div><div class="line">				<span class="keyword">return</span> interrupted;</div><div class="line">			}</div><div class="line">			<span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())</div><div class="line">			<span class="comment">//否则，检查前一个节点的状态，看当前获取锁失败的线程是否需要挂起。</span></div><div class="line">			<span class="comment">//如果需要，借助JUC包下的LockSopport类的静态方法Park挂起当前线程。知道被唤醒。</span></div><div class="line">				interrupted = <span class="keyword">true</span>;</div><div class="line">		}</div><div class="line">	} <span class="keyword">finally</span> {</div><div class="line">		<span class="keyword">if</span> (failed)</div><div class="line">			cancelAcquire(node);<span class="comment">// 如果有异常就取消请求，将当前节点从队列中移除。</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>从上面可以看出，当一个线程试着获取锁时：</p>
<ul>
<li>成功获取到锁，不用进入AQS队列。</li>
<li>失败，被挂起，等待下次唤醒后继续循环尝试获取锁。</li>
</ul>
<h2 id="unlock方法">unlock方法</h2>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="概述">概述</h2>
<p>对于ReentrantLock,通常是这么使用它的：</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1<]]>
    </summary>
    
      <category term="Java，JUC，源码" scheme="http://yoursite.com/tags/Java%EF%BC%8CJUC%EF%BC%8C%E6%BA%90%E7%A0%81/"/>
    
      <category term="JUC源码分析" scheme="http://yoursite.com/categories/JUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《HTTP权威指南》读书笔记1 - 连接管理]]></title>
    <link href="http://yoursite.com/2015/08/09/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/"/>
    <id>http://yoursite.com/2015/08/09/http权威指南读书笔记1/</id>
    <published>2015-08-09T06:11:51.000Z</published>
    <updated>2016-03-21T16:43:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-HTTP如何使用TCP连接">1.HTTP如何使用TCP连接</h2>
<h3 id="1-1_TCP连接">1.1 TCP连接</h3>
<p>HTTP通信是基于TCP/IP，web浏览器与服务器的交互如下图：<br><img src="/img/HTTPConnections_1.jpg" alt="alt text"></p>
<p>TCP为HTTP提供了一条可靠的比特传输管道， TCP会按序、无差错的传输HTTP数据。</p>
<h3 id="1-2_TCP流是分段的，由IP分组传输">1.2 TCP流是分段的，由IP分组传输</h3>
<p>TCP数据是通过IP分组或IP数据报传输，而HTTP通信基于TCP/IP，所以HTTP处于”HTTP over TCP over IP”协议栈的顶层。HTTPS是在HTTP与TCP之间插入了一层密码加密层(TLS或SSL)，层次图如下：<br><img src="/img/HTTPConnections_2.jpg" alt="alt text"></p>
<p>当HTTP需要传输消息时，会以流的形式将报文数据的内容通过一条打开的TCP连接按序传输。TCP收到数据流之后，会将数据流砍成被称作段的小数据块，并将段封装在IP分组中，通过因特网进行传输。</p>
<p>每一个TCP段都是由IP分组承载，由一个IP地址发送到另外一个IP地址。每个IP组都包含：</p>
<ul>
<li>一个IP分组首部(通常为20字节)</li>
<li>一个TCP段首部(通常为20字节)</li>
<li>一个TCP数据块(0个或多个字节)</li>
</ul>
<p>IP首部包含了源和目的IP地址、长度和其他一些标记。TCP段的首部包含了TCP端口号、TCP控制标记，以及用于数据排序和完整性检查的一些数字值:</p>
<p><img src="/img/HTTPConnections_3.jpg" alt="alt text"></p>
<h3 id="1-3_保持TCP连接的正确运行">1.3 保持TCP连接的正确运行</h3>
<p>TCP是通过端口号来保持TCP连接的正确运行的，通过以下4个值来区分不同的TCP连接：</p>
<ul>
<li>&lt;源IP地址、源端口号、目的IP地址、目的端口号&gt;</li>
</ul>
<h2 id="2-对TCP性能的考虑">2.对TCP性能的考虑</h2>
<h3 id="2-1_HTTP事务时延">2.1 HTTP事务时延</h3>
<p>下图描述了HTTP事务主要的连接、传输以及处理时延：<br><img src="/img/HTTPConnections_4.jpg" alt="alt text"></p>
<p>与建立TCP连接，以及传输请求和响应报文的时间相比，事务处理时间可能是很短的。除非客户端或服务器超载，或正在处理复杂的动态资源，否则HTTP时延就是由TCP网络时延构成的。</p>
<p>HTTP事务的时延有以下几种主要原因：</p>
<ul>
<li>DNS寻址时延，如果DNS没有被本地缓存，通过DNS解析系统将URI中的主机名转换成一个IP地址可能要花费数十秒的时间。</li>
<li>连接时延，TCP三次握手开销。</li>
<li>传输时延，HTTP请求通过TCP管道传输造成的时延。</li>
<li>处理时延，web服务器写回HTTP response也需要时间。</li>
</ul>
<p><img src="/img/HTTPConnections_5.png" alt="alt text"></p>
<h3 id="2-2_TCP连接握手时延">2.2 TCP连接握手时延</h3>
<p><img src="/img/HTTPConnections_6.jpg" alt="alt text"></p>
<p>当HTTP事务传输数据很少时，TCP的SYN/SYN+ACK握手会产生一个可以测量的时延。小的HTTP事务可能花费超过50%的时间在TCP连接建立。因此需要利用长连接等特性来复用这个TCP连接。</p>
<h3 id="2-3_延迟确认(Delayed_ACK)">2.3 延迟确认(Delayed ACK)</h3>
<p>每个TCP段都有一个序列号和一个数据完整性校验和(data-integrity checksum)。每个段的接收者收到完好的段时，都会向发送者回送一个小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者就会认为分组已被破坏或损毁，并重发数据.</p>
<p>由于确认报文很小，所以TCP允许在发往相同方向的输出数据分组中对其进行“捎带”。TCP将返回的确认信息与输出的数据分组结合在一起，可以更有效地利用网络。TCP在何时发送ack给对方有以下规定：</p>
<ol>
<li>当有响应数据要发送时,ack会随响数据立即发送给对方.</li>
<li>如果没有响应数据,ack的发送将会有一个延迟,以等待看是否有响应数据可以一起发送,这称是”Delayed Ack”.但这个延迟最多不会超过500ms,一般为200ms.如果在200ms内有数据要发送,那么ack会随数据一起立即发送给对方.<strong>注意这里的延迟200ms,不是指的从接受到对方数据到发送ack的最长等待时间差.而是指的内核启动的一个定时器,它每隔200ms就查看下是否有ack要发送.</strong>例如:假设定时器在0ms时启动,对方的数据段在<br>185ms时到达,那么ack最迟会在200ms时发送,而不是385ms时发送.</li>
<li>如果在等待发送ack期间,对方的第二个数据段又到达了,这时要立即发送ack.但是如果对方的三个数据段相继到达,那么第二个数据段到达时ack立即发送,但第三个数据段到达时是否立即发送,则取决于上面两条.</li>
</ol>
<h3 id="2-4_TCP慢启动">2.4 TCP慢启动</h3>
<p>TCP数据传输的性能还取决于TCP连接的使用期（age）。TCP连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐被称为TCP慢启动（slow start），用于防止因特网的突然过载和拥塞。</p>
<p>可以使用持久连接来解决慢启动问题。</p>
<h3 id="2-5_Nagle算法">2.5 Nagle算法</h3>
<p>Nagle算法鼓励发送全尺寸（LAN上最大尺寸的分组大约是1500字节，在因特网上是几百字节）的段。只有当所有其他分组都被确认之后，Nagle算法才允许发送非全尺寸的分组。如果其他分组仍然在传输过程中，就将那部分数据缓存起来。只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸分组的数据时，才会将缓存的数据发送出去。</p>
<p>下面是Nagle算法的伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> there is <span class="keyword">new</span> data to send</div><div class="line">  <span class="keyword">if</span> the window size &gt;= MSS and available data is &gt;= MSS</div><div class="line">    send complete MSS segment now</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">if</span> there is unconfirmed data still in the pipe</div><div class="line">      enqueue data in the buffer until an acknowledge is received</div><div class="line">    <span class="keyword">else</span></div><div class="line">      send data immediately</div><div class="line">    end <span class="keyword">if</span></div><div class="line">  end <span class="keyword">if</span></div><div class="line">end <span class="keyword">if</span></div></pre></td></tr></table></figure>

<h3 id="2-6_Nagle算法与Delayed_ACK同时出现的问题">2.6 Nagle算法与Delayed ACK同时出现的问题</h3>
<p>A 和B进行数据传输 :  A运行Nagle算法，B运行delayed ACK算法：</p>
<ol>
<li>A-&gt;B 发一个packet, B不回应，delay ACK</li>
<li>A-&gt;B 再发一个packet</li>
<li>B收到第二个packet(数据包)，这时候会回应第一个packet(数据包)，即第一个ACK</li>
<li>假设这时候A里的数据已经&lt;MSS，则A将停止发送数据，等待第二个packet(数据包)的ACK</li>
</ol>
<p>此时问题就来了，因为A没有收到第二个packet的ACK确认，同时数据&lt;MSS，由Nagle算法可以得知，这段数据将被被存到缓冲区等待发送，同时这时候B也在等A再发一个packet然后再回应一个ACK,所以这样A和B就发生了死锁了，但是Delayed Ack是有等待机制的，就是会等待500ms,一般是200ms，如果在这200ms内有数据数据要发送(ACK)，就回应一个packet(数据包)的ACK,这样就会打破这种死锁的问题。即只有当200ms(或小于200ms)的延迟过后双方才会继续传输。</p>
<h3 id="2-7_TIME_WAIT累积与端口耗尽">2.7 TIME_WAIT累积与端口耗尽</h3>
<p>当某个TCP端点关闭TCP连接时，会在内存中维护一个小的控制块，用来记录所关闭的连接的IP地址和端口号。这个信息通常只能存在一个小时间段。这个算法可以防止在短时间内创建、关闭具有相同IP和端口号的连接。</p>
<p>TIME_WAIT的作用：允许老的重复分组在网络中消失，防止最后ACK的丢失，可靠地实现TCP全双工通信的终止。</p>
<h2 id="3_HTTP连接的处理">3 HTTP连接的处理</h2>
<p>Connection首部可以提供三种类型不同的标签：</p>
<ul>
<li>HTTP首部字段名，列出了只与此连接有关的首部</li>
<li>任意标签纸，用于描述此连接的非标准选项</li>
<li>close，说明操作完成后需要关闭这条持久连接</li>
</ul>
<h3 id="3-1_并行连接(Parallel_Connections)">3.1 并行连接(Parallel Connections)</h3>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-HTTP如何使用TCP连接">1.HTTP如何使用TCP连接</h2>
<h3 id="1-1_TCP连接">1.1 TCP连接</h3>
<p>HTTP通信是基于TCP/IP，web浏览器与服务器的交互如下图：<br><img src="/img/HTTPC]]>
    </summary>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/categories/HTTP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[static关键字]]></title>
    <link href="http://yoursite.com/2014/11/01/static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2014/11/01/static关键字/</id>
    <published>2014-11-01T14:27:42.000Z</published>
    <updated>2016-03-21T16:41:00.000Z</updated>
    <content type="html"><![CDATA[<h3 id="static关键字">static关键字</h3>
<p>使用static关键字的时机:</p>
<ul>
<li>希望没有创建对象就可以使用某个方法。</li>
<li>无论创建多少对象时，都希望为某个特殊的域(field)分配单一存储空间。</li>
</ul>
<p>当声明一个事物是static时，就意味着这个field或function不会与包含它的那个类的任何对象实例关联在一起。所以即使没有创建类的实例，也可以通过访问类的static的field或function.</p>
<p>使用类名是引用static变量的首选方式：</p>
<ul>
<li>强调了这个变量的static属性。</li>
<li>为编译器优化创造了更好的机会。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="static关键字">static关键字</h3>
<p>使用static关键字的时机:</p>
<ul>
<li>希望没有创建对象就可以使用某个方法。</li>
<li>无论创建多少对象时，都希望为某个特殊的域(field)分配单一存储空间。</li>
</ul]]>
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[抽象语法树]]></title>
    <link href="http://yoursite.com/2014/10/26/%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/"/>
    <id>http://yoursite.com/2014/10/26/抽象语法树/</id>
    <published>2014-10-26T12:11:39.000Z</published>
    <updated>2016-03-21T16:44:22.000Z</updated>
    <content type="html"><![CDATA[<p>Abstract Syntax Tree</p>
<h3 id="The_Abstract_Syntax_Tree">The Abstract Syntax Tree</h3>
<p><strong>抽象语法树</strong>是Eclipse处理源代码的方式，每一个Java源文件都可以用AST的节点来表示。这些节点都是ASTNode的子类。每一个子类都代表Java语言中的一个element。例如：MethodDeclaration是用来描述方法声明的节点，VariableDeclarationFragment用来描述变量声明。一个频繁使用的node是<strong>SimpleName</strong>,SimpleName是Java源代码中的除了<strong>关键词</strong>、<strong>布尔表达式</strong>或者<strong>null</strong>外的任何一个字符串。</p>
<p>所有与AST相关的类都位于org.eclipse.jdt.core.dom包中。</p>
<h3 id="Parsing_source_code">Parsing source code</h3>
<p><strong>ASTParser</strong>将Java代码解析为AST，它即可以解析整个Java文件也可以包括部分Java代码。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> CompilationUnit <span class="title">parse</span>(ICompilationUnit unit){</div><div class="line">    ASTParser parser = ASTParser.newParser(AST.JLS3);</div><div class="line">    parser.setKind(ASTParser.K_COMPILATION_UNIT);</div><div class="line">	parser.setSource(unit); <span class="comment">// set source</span></div><div class="line">	parser.setResolveBindings(<span class="keyword">true</span>); <span class="comment">// we need bindings later on</span></div><div class="line">	<span class="keyword">return</span> (CompilationUnit) parser.createAST(<span class="keyword">null</span> <span class="comment">/* IProgressMonitor */</span>);      <span class="comment">// parse</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>通过<strong>ASTParser.newParser(AST.JLS3)</strong>,我们让解析器通过Java语言标准第三版来解析代码。<br><strong>parser.setKind(ASTParser.K_COMPILATION_UNIT)</strong>告诉解析器需要解析ICompilationUnit,ICompilation是一个Java文件。</p>
<h3 id="Java_Model">Java Model</h3>
<p>Java Model将一个Java项目展示为一种树形结构，展示为大家都知道的”Package Explorer”视图：<br><img src="http://www.eclipse.org/articles/Article-JavaCodeManipulation_AST/images/java-model-overview.png" alt="Alt text"></p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();</div><div class="line">IProject project = root.getProject(<span class="string">"someJavaProject"</span>);</div><div class="line">project.open(<span class="keyword">null</span> <span class="comment">/* IProgressMonitor */</span>);</div><div class="line">		</div><div class="line">IJavaProject javaProject = JavaCore.create(project);</div><div class="line">IType lwType = javaProject.findType(<span class="string">"net.sourceforge.earticleast.app.Activator"</span>);</div><div class="line">ICompilationUnit lwCompilationUnit = lwType.getCompilationUnit();</div></pre></td></tr></table></figure>

<h3 id="How_to_find_an_AST_node">How to find an AST node</h3>
<p>即使是一个简单地“Hello World”的项目经过解析生成的AST也是非常的复杂的。那么这时如何拿到<em>println(“Hello World”)</em>?扫描所有的节点是可以做到的，但是并不方便。</p>
<p>更好的解决方案是：每一个<strong>ASTNode</strong>允许经过一个<strong>visitor</strong>查询子节点(<a href="http://en.wikipedia.org/wiki/Visitor_pattern" target="_blank" rel="external">visitor pattern</a>)。每一个<strong>ASTNode</strong>子类都有两个方法：visit()、endVisit()。<strong>ASTNode</strong>上定义了两个方法：preVisit(ASTNode node)和postVisit(ASTNode node).</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">visit</span>(VariableDeclarationStatement node){</div><div class="line">    <span class="keyword">for</span>(Iterator iter = node.fragments().iterator();iter.hasNext();){</div><div class="line">        VariableDeclarationFragment fragment = (VariableDeclarationFragment) iter.next();</div><div class="line">        <span class="comment">//... store these fragments somewhere</span></div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// prevent that SimpleName is interpreted as reference</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>当visit()返回false时，subtree的访问节点都不被考虑。</p>
<h3 id="Objtaining_Information_from_an_AST_Node">Objtaining Information from an AST Node</h3>
<p>每一个<strong>ASTNode</strong>的子类都含有它代表的Java元素的详细信息。例如，一个<em>MethodDeclaration</em>将会含有方法的名字，返回类型，参数等信息。一个节点的信息被称为<em>structural properties</em>。</p>
<p>对于下面的方法而言：</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span>(BundleContext context) <span class="keyword">throws</span> Exception {</div><div class="line">    <span class="keyword">super</span>.start(context);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面的图表示它的结构化的属性：<br><img src="http://www.eclipse.org/articles/Article-JavaCodeManipulation_AST/images/md-astview.png" alt="Alt text"></p>
<p>可以通过静态方法或者泛型方法得到节点的结构化属性：</p>
<ul>
<li>static methods: 每个节点都共有的方法去访问它们的属性：例如getName(), exceptions(), 等等。</li>
<li>generic method: 使用<em>getStructuralProperty(StructuralPropertyDescriptor property)</em>方法拿到节点属性值。每一个AST的子类都定义了一系列的<strong>StructuralPropertyDescriptor</strong>, <strong>StructuralPropertyDescriptor</strong>都可以直接通过它们属于的类访问。</li>
</ul>
<p><strong>Sructural Properties</strong>分为三种不同的类型：</p>
<ul>
<li>properties that hold simple values</li>
<li>properties which contain a single child AST node</li>
<li>properties which contain a list of child AST nodes.</li>
</ul>
<h2 id="Bindings">Bindings</h2>
<h2 id="Error_Recovery">Error Recovery</h2>
<p>从Eclipse3.2以后，AST/DOM支持从错误的语法中恢复代码，如果需要使用这个属性，你需要使用ASTParser#setStatementsRecovery(). 正如它的名字所说，错误恢复是在声明级别完成的。错误恢复并不能应用于所有的语法错误，对于简单地忘记分号却已经不再是问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">	System.out.print(<span class="string">"Hello"</span>);</div><div class="line">	System.out.print(<span class="string">", "</span>)</div><div class="line">	System.out.println(<span class="string">"World!"</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>对于上面的代码，在Eclipse3.2以前，这个方法体将会是空的，现在可以通过错误恢复有可能能够拿到那些方法调用。</p>
<h2 id="How_to_Apply_Changes">How to Apply Changes</h2>
<h2 id="Write_it_down">Write it down</h2>
<p>当你使用ASTRewrite或者直接更改树的节点，这些改动将被重新写回Java源文件，因此一个TextEdit对象将会被创建，这时代码将会离开AST的环境，而进入一个基本文本的环境。<strong>TextEdit</strong>对象含有基于字符的更改信息，它是<em>org.eclipse.text</em>插件的一部分。</p>
<p>可以通过以下两种不同的方式获取<strong>TextEdit</strong>对象：</p>
<ul>
<li>如果使用ASTRewrite,请求<em>ASTRewrite</em>的实例调用<em>rewriteAST(IDocument, Map)</em>方法获取<strong>TextEdit</strong>对象。</li>
<li><p>如果直接修改AST节点，<strong>TextEdit</strong>对象通过<em>CompilationUnit</em>的rewrite(IDocument document, Map options)获得。<br>对于<em>rewrite(IDocument document, Map options)</em>方法，第一个参数<em>document</em>包含了需要被修改的源代码，第二个参数是一个关于源代码格式化可选项的映射，传null就是使用默认的选项。</p>
</li>
<li><p>当需要解析的源代码是一个char[]时，或者IDocument对象很容易，创建一个*org.eclipse.jface.text.Document对象，并且将这个char[]数组作为构造器参数传入。</p>
</li>
<li>当需要解析的源代码是Java源文件时，你不能直接写入到这个文件，因为你有可能不是唯一操作这个源文件的编辑器。对于Eclipse，Java编辑器并不是直接写至源文件，而是使用一个拷贝代替。</li>
</ul>
<p>下面的代码表示了如何进行写操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ITextFileBufferManager bufferManager = FileBuffers.getTextFileBufferManager(); <span class="comment">// get the buffer manager</span></div><div class="line">IPath path = unit.getJavaElement().getPath(); <span class="comment">// unit: instance of CompilationUnit</span></div><div class="line"><span class="keyword">try</span> {</div><div class="line">	bufferManager.connect(path, <span class="keyword">null</span>); <span class="comment">// (1)</span></div><div class="line">	ITextFileBuffer textFileBuffer = bufferManager.getTextFileBuffer(path);</div><div class="line">	<span class="comment">// retrieve the buffer</span></div><div class="line">	IDocument document = textFileBuffer.getDocument(); (<span class="number">2</span>)</div><div class="line">	<span class="comment">// ... edit the document here ... </span></div><div class="line">	</div><div class="line">  <span class="comment">// commit changes to underlying file</span></div><div class="line">	textFileBuffer</div><div class="line">		.commit(<span class="keyword">null</span> <span class="comment">/* ProgressMonitor */</span>, <span class="keyword">false</span> <span class="comment">/* Overwrite */</span>); <span class="comment">// (3)</span></div><div class="line"></div><div class="line">} <span class="keyword">finally</span> {</div><div class="line">	bufferManager.disconnect(path, <span class="keyword">null</span>); <span class="comment">// (4)</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Managing_Comments">Managing Comments</h3>
<p>修改AST中一个最困难的就是处理comment.<strong>CompilationUnit#getCommentList()</strong>方法可以返回comments的集合，但是这个集合不能被修改，这意味着即使AST Rewriter往一个可编译单元中添加了一个comment，新的comment也无法出现在这个comment的集合中。</p>
<p>下面的代码片段可以用来添加comment：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">CompilationUnit astRoot= ... ; <span class="comment">// get the current compilation unit</span></div><div class="line"></div><div class="line">ASTRewrite rewrite= ASTRewrite.create(astRoot.getAST());</div><div class="line">Block block= ((TypeDeclaration) astRoot.types().get(<span class="number">0</span>)).getMethods()[<span class="number">0</span>].getBody();</div><div class="line">ListRewrite listRewrite= rewrite.getListRewrite(block, Block.STATEMENTS_PROPERTY);</div><div class="line">Statement placeHolder= rewrite.createStringPlaceholder(<span class="string">"//mycomment"</span>, ASTNode.EMPTY_STATEMENT);</div><div class="line">listRewrite.insertFirst(placeHolder, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">textEdits= rewrite.rewriteAST(document, <span class="keyword">null</span>);</div><div class="line">textEdits.apply(document);</div></pre></td></tr></table></figure>

<p>如果comment是javadoc comment，可以使用getJavadoc()方法获得相应的声明。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Abstract Syntax Tree</p>
<h3 id="The_Abstract_Syntax_Tree">The Abstract Syntax Tree</h3>
<p><strong>抽象语法树</strong>是Eclipse处理源代码的方式，每一个Java源文件都可以用AST的节点来表示。这些节点都是ASTNode的子类。每一个子类都代表Java语言中的一个element。例如：MethodDeclaration是用来描述方法声明的节点，VariableDeclarationFragment用来描述变量声明。一个频繁使用的node是<strong>SimpleName</strong>,SimpleName是Java源代码中的除了<strong>关键词</strong>、<strong>布尔表达式</strong>或者<strong>null</strong>外的任何一个字符串。</p>
<p>所有与AST相关的类都位于org.eclipse.jdt.core.dom包中。</p>
<h3 id="Parsing_source_code">Parsing source code</h3>
<p><strong>ASTParser</strong>将Java代码解析为AST，它即可以解析整个Java文件也可以包括部分Java代码。</p>
]]>
    
    </summary>
    
      <category term="AST" scheme="http://yoursite.com/tags/AST/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Eclipse Plugin" scheme="http://yoursite.com/tags/Eclipse-Plugin/"/>
    
      <category term="Eclipse Plugin Development" scheme="http://yoursite.com/categories/Eclipse-Plugin-Development/"/>
    
  </entry>
  
</feed>
