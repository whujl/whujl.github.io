<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>遥远的小村庄</title>
  <meta name="author" content="Jiao Long">
  
  <meta name="description" content="Roger&#39;s blog | java | iOS | swift">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="遥远的小村庄"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="遥远的小村庄" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-56109842-1']);
  
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">遥远的小村庄</a></h1>
  <h2><a href="/">仰望星空，脚踏实地</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-31T12:56:16.000Z"><a href="/2016/03/31/冒泡排序/">3月 31 2016</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/31/冒泡排序/">冒泡排序</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="介绍">介绍</h2>
<p>设数组长度为N,从小向大排序:</p>
<ol>
<li><p>比较相邻的前后两个数据，如果前面数据大于后面的数据，就将两个数据交换。</p>
</li>
<li><p>这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。</p>
</li>
<li><p>N=N-1，如果N不为0就重复前面二步，否则排序完成。</p>
</li>
</ol>
<h2 id="时间复杂度和稳定性">时间复杂度和稳定性</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<p>冒泡排序的时间复杂度是O(N^2)，假设数组中有N个元素，遍历一趟的时间复杂度是O(N),需要遍历N-1次，因此时间复杂度为O(N^2)。</p>
<h3 id="稳定性">稳定性</h3>
<p>冒泡排序是稳定的排序，如果前后两个元素相等，不会交换前后顺序。</p>
<h2 id="实现">实现</h2>
<h3 id="基本实现">基本实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span>(<span class="keyword">int</span>[] a) {</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) {</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; a.length - i; j++) {</div><div class="line">            <span class="keyword">if</span> (a[j - <span class="number">1</span>] &gt; a[j]) {</div><div class="line">                swap(a, j, j - <span class="number">1</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="优化一：如果没有发生交换则停止排序">优化一：如果没有发生交换则停止排序</h3>
<p>设置一个flag表示这趟是否发生交换，如果交换则为true， 否则为false。这样如果一趟没有发生交换，则说明排序完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span>(<span class="keyword">int</span>[] a){</div><div class="line">    <span class="keyword">int</span> n = a.length;</div><div class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(flag){</div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt; n; i++){</div><div class="line">            <span class="keyword">if</span>(a[i-<span class="number">1</span>] &gt; a[i]){</div><div class="line">                swap(a, i, i-<span class="number">1</span>);</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        n--;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="优化二:_对于只有前面部分无序数组优化">优化二: 对于只有前面部分无序数组优化</h3>
<p>如果对于一个很大的数组，只有前面部分是无序状态，后面都已经有序，那么在一次遍历以后，只需要记录下这个位置，下次遍历只需要遍历前面这部分无序数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span>(<span class="keyword">int</span>[] a) {</div><div class="line">       <span class="keyword">int</span> flag = a.length;</div><div class="line"></div><div class="line">       <span class="keyword">while</span> (flag &gt; <span class="number">0</span>) {</div><div class="line">           <span class="keyword">int</span> k = flag;</div><div class="line">           flag = <span class="number">0</span>;</div><div class="line"></div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k; j++) {</div><div class="line">               <span class="keyword">if</span> (a[j - <span class="number">1</span>] &gt; a[j]) {</div><div class="line">                   swap(a, j, j - <span class="number">1</span>);</div><div class="line">                   flag = j;</div><div class="line">               }</div><div class="line">           }</div><div class="line">       }</div><div class="line">}</div></pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-28T09:38:29.000Z"><a href="/2016/03/28/ThreadLocal详解/">3月 28 2016</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/28/ThreadLocal详解/">ThreadLocal详解</a></h1>
  

    </header>
    <div class="entry">
      
        <p>ThreadLocal用于提供线程局部变量，即通过get()和set()方法访问某个变量的线程都有自己的局部变量。但它是通过各个线程自己创建对象，然后调用set方法设置进去，而不是由ThreadLocal自己来创建变量副本。</p>
<h2 id="存储">存储</h2>
<p>ThreadLocal作为线程局部变量，那么应该就存在Thread对象中，可以从Thread源码中找到线程局部变量存储的地方：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></div><div class="line">    * by the ThreadLocal class. */</div><div class="line">   ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div><div class="line">   </div><div class="line">   <span class="javadoc">/**</span></div><div class="line">    * ThreadLocalMap is a customized hash map suitable only for</div><div class="line">    * maintaining thread local values. No operations are exported</div><div class="line">    * outside of the ThreadLocal class. The class is package private to</div><div class="line">    * allow declaration of fields in class Thread.  To help deal with</div><div class="line">    * very large and long-lived usages, the hash table entries use</div><div class="line">    * WeakReferences for keys. However, since reference queues are not</div><div class="line">    * used, stale entries are guaranteed to be removed only when</div><div class="line">    * the table starts running out of space.</div><div class="line">    */</div><div class="line">   static <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span></span>{</div><div class="line">    	<span class="javadoc">/**</span></div><div class="line">        * The entries in this hash map extend WeakReference, using</div><div class="line">        * its main ref field as the key (which is always a</div><div class="line">        * ThreadLocal object).  Note that null keys (i.e. entry.get()</div><div class="line">        * == null) mean that the key is no longer referenced, so the</div><div class="line">        * entry can be expunged from table.  Such entries are referred to</div><div class="line">        * as "stale entries" in the code that follows.</div><div class="line">        */</div><div class="line">       static <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>{</div><div class="line">           <span class="javadoc">/** The value associated with this ThreadLocal. */</span></div><div class="line">           Object value;</div><div class="line"></div><div class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) {</div><div class="line">               <span class="keyword">super</span>(k); <span class="comment">//将ThreadLocal对象转换为弱引用对象，作为key。</span></div><div class="line">               value = v;</div><div class="line">           }</div><div class="line">       }</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>可以看到ThreadLocal.ThreadLocalMap 是 ThreadLocal 的一个静态内部类,采用定制化的HashMap用来存储线程局部变量，放置于Entry类中，Entry类继承与WeakRefernce<threadlocal<?>&gt;。</threadlocal<?></p>
<p>下面是ThreadLocalMap的构造函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line">      * Construct a new map initially containing (firstKey, firstValue).</div><div class="line">      * ThreadLocalMaps are constructed lazily, so we only create</div><div class="line">      * one when we have at least one entry to put in it.</div><div class="line">      */</div><div class="line">     ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) {</div><div class="line">         table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</div><div class="line">         <span class="keyword">int</span> i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - <span class="number">1</span>);</div><div class="line">         table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</div><div class="line">         size = <span class="number">1</span>;</div><div class="line">         setThreshold(INITIAL_CAPACITY);</div><div class="line">     }</div></pre></td></tr></table></figure>

<p>可以看出ThreadLocalMap是采用一个INITIAL_CAPACITY大小的Entry数组保存ThreadLocao的key-value信息，并且索引是通过firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1)来实现。</p>
<h2 id="set方法">set方法</h2>
<p>下面来看ThreadLocal的set方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(T <span class="keyword">value</span>) {</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            map.<span class="keyword">set</span>(<span class="keyword">this</span>, <span class="keyword">value</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            createMap(t, <span class="keyword">value</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">ThreadLocalMap getMap(Thread t) {</div><div class="line">        <span class="keyword">return</span> t.threadLocals;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> createMap(Thread t, T firstValue) {</div><div class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span>(ThreadLocal&lt;?&gt; key, Object <span class="keyword">value</span>) {</div></pre></td></tr></table></figure>

<p>在往ThreadLocal里设置值得时候先拿到当前线程，接着去获得当前线程的ThreadLocalMap，如果为null，则进行初始化，这里采用了延迟初始化技术。否则就将threadlocal实例-value这种k-v键值对放入map。</p>
<p>接下来查看ThreadLocalMap的set方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span>(ThreadLocal&lt;?&gt; key, Object <span class="keyword">value</span>) {</div><div class="line">            Entry[] tab = table;</div><div class="line">            <span class="keyword">int</span> len = tab.length;</div><div class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode & (len-<span class="number">1</span>);</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (Entry e = tab[i];</div><div class="line">                 e != <span class="keyword">null</span>;</div><div class="line">                 e = tab[i = nextIndex(i, len)]) {</div><div class="line">                ThreadLocal&lt;?&gt; k = e.<span class="keyword">get</span>();</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (k == key) {</div><div class="line">                    e.<span class="keyword">value</span> = <span class="keyword">value</span>;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) {</div><div class="line">                    replaceStaleEntry(key, <span class="keyword">value</span>, i);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">            tab[i] = <span class="keyword">new</span> Entry(key, <span class="keyword">value</span>);</div><div class="line">            <span class="keyword">int</span> sz = ++size;</div><div class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) && sz &gt;= threshold)</div><div class="line">                rehash();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>一个线程中有多少个线程局部对象要保存，那么就初始化多少个 Entry 对象来保存。</p>
<p>每一次在往ThreadLocalMap中添加值的时候都会进行扫描以及资源回收。每一次调用ThreadLocalMap的genEntry函数或者set函数，都可以进行内存回收，但是保证get和set函数一直被调用到是不可能任何情况都成立的，因此所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。</p>
<p>ThreadLocalMap 中 private Entry[] table 的初始大小是16，超过容量的2/3时，会进行rehash和扩容。</p>
<h2 id="get方法">get方法</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> T <span class="title">get</span>() {</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) {</div><div class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) {</div><div class="line">                @SuppressWarnings(<span class="string">"unchecked"</span>)</div><div class="line">                T result = (T)e.<span class="keyword">value</span>;</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> setInitialValue();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> T <span class="title">setInitialValue</span>() {</div><div class="line">        T <span class="keyword">value</span> = initialValue();</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            map.<span class="keyword">set</span>(<span class="keyword">this</span>, <span class="keyword">value</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            createMap(t, <span class="keyword">value</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>调用ThreadLocal的get方法时会先拿到当前线程，并根据当前线程拿到ThreadLocalMap变量，如果map不为空，通过当前threadlocal为key拿到对应的值，并返回。如果map为空，那么去设置初始化的值，这里需要通过复写initialValue()设置初值。如果没有override，会返回null，但是ThreadLocalMap还是进行了初始化。</p>
<h2 id="总结">总结</h2>
<ol>
<li>每个Thread维护一个ThreadLocalMap映射表，这个映射表的key是ThreadLocal实例本身，value是真正需要存储的Object。这样设计之后每个Map的Entry数量变小了:之前是Thread的数量，现在是ThreadLocal的数量，能提高性能。并且当Thread销毁之后对应的ThreadLocalMap也就随之销毁了，能减少内存使用量。</li>
<li>线程死亡时，线程局部变量会自动回收内存；</li>
<li>线程局部变量时通过一个 Entry 保存在map中，该Entry 的key是一个 WeakReference包装的ThreadLocal, value为线程局部变量; key 到 value 的映射是通过：ThreadLocal.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1) 来完成的；</li>
<li>当线程拥有的局部变量超过了容量的2/3(没有扩大容量时是10个)，会涉及到ThreadLocalMap中Entry的回收；</li>
</ol>
<h2 id="参考">参考</h2>
<ol>
<li><a href="http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/index.html" target="_blank" rel="external">http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/index.html</a></li>
<li><a href="http://zhuanlan.zhihu.com/winwill2012/20213204" target="_blank" rel="external">http://zhuanlan.zhihu.com/winwill2012/20213204</a></li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-27T17:14:18.000Z"><a href="/2016/03/28/Java线程的终止/">3月 28 2016</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/28/Java线程的终止/">Java线程的终止</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Java没有提供任何机制来安全地终止线程，因此只有通过一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。</p>
<p>一个可取消的任务必须拥有取消策略，在这个策略中详细地定义取消操作的”How”/“When”/“what”，即其他代码如何请求取消该任务，在何时检查是否已经取消了请求，以及相应取消请求时应该执行哪些操作。</p>
<p>下面介绍几种取消任务的方法：</p>
<h2 id="使用volatile设置已请求取消标志">使用volatile设置已请求取消标志</h2>
<p>这种方式通过设置一个“已请求取消标志”，任务定期地咋查看该flag,如果设置了这个标志，那么任务将提前结束：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeGenerator</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;BigInteger&gt; primes = <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(){</div><div class="line">		BigInteger p = BigInteger.ONE;</div><div class="line">		<span class="keyword">while</span>(!cancelled){</div><div class="line">			p = p.nextProbablePrime();</div><div class="line">			<span class="keyword">synchronized</span>(<span class="keyword">this</span>){</div><div class="line">				primes.add(p);</div><div class="line">			}</div><div class="line">		}</div><div class="line">		</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span>(){</div><div class="line">		<span class="keyword">this</span>.cacelled = <span class="keyword">true</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;BigInteger&gt; <span class="title">get</span>(){</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(primes);</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果这些需要使用生产者消费者，生产者线程生成素数，并将它们放入到一个阻塞队列。如果生产者的速度超过了消费者的处理速度，队列将被填满，put方法也会阻塞。当生产者在put方法中阻塞时，如果消费者希望取消生产者任务，将cancelled设置为true，但是这时生产者还处于阻塞状态，无法检查这个flag，也无法停止生产。</p>
<h2 id="使用中断实现取消">使用中断实现取消</h2>
<p>对于上面介绍这种情况，可以使用中断而不是boolean标志来请求取消。因为每个线程都有一个boolean类型的中断状态，当中断线程时，这个线程的中断状态将被置为true。中断并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的取消点中断自己。</p>
<p>这种中断机制与取消标志位相比，它能够与可阻塞的库函数实现良好交互。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>{</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">PrimeProducer</span>(BlockingQueue&lt;BigInteger queue){</div><div class="line">		<span class="keyword">this</span>.queue = queue;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(){</div><div class="line">		<span class="keyword">try</span>{</div><div class="line">			BigInteger p = BigInteger.ONE;</div><div class="line">			<span class="keyword">while</span>(!Thread.currentThread.isInterrupted()){</div><div class="line">				queue.put(p = p.nextProbablePrime());</div><div class="line">			}<span class="keyword">catch</span>(InterruptedException consumed){</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span>(){</div><div class="line">		interrupt();</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里虽然调用了put方法，put方法会相应中断，因此并不一定需要进行显式的检测。但执行检测却会使PrimeProducer对中断具有更高的相应性，因为它是在启动寻找素数任务之前检查中断的，而不是在任务完成之后。</p>
<p>当调用可中断的阻塞函数时，两种实用策略可用于处理InterruptedException：</p>
<ul>
<li>传递异常，从而使你的方法也称为可中断的阻塞方法。</li>
<li>恢复中断状态，从而使调用栈中的上层代码能够对其进行处理。</li>
</ul>
<h2 id="使用Future实现取消">使用Future实现取消</h2>
<p>Future拥有cancel方法可以取消任务，该方法具有一个boolean类型参数”mayInterrupteIfRunning”，如果为true并且任务正在某个线程中运行，那么这个线程可以被中断。如果这个参数为false,那么意味着“若任务还没有启动，就不要运行它”。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> timedRun(Runnable r, <span class="keyword">long</span> timeout, TimeUnit unit) </div><div class="line">					<span class="keyword">throws</span> InterruptedException{</div><div class="line">	Future&lt;?&gt; <span class="keyword">task</span> = taskExec.submit(r);</div><div class="line">	<span class="keyword">try</span>{</div><div class="line">		<span class="keyword">task</span>.get(timeout, unit);</div><div class="line">	}<span class="keyword">catch</span>(TimeoutException e){</div><div class="line">		<span class="comment">//接下来任务将被取消</span></div><div class="line">	}<span class="keyword">catch</span>(ExecutionException e){</div><div class="line">		<span class="comment">//如果在任务中抛出了异常，那么重新抛出该异常</span></div><div class="line">		<span class="keyword">throw</span> launderThrowable(e.getCause());</div><div class="line">	}<span class="keyword">finally</span>{</div><div class="line">		<span class="comment">//如果任务已经结束，那么执行取消操作也不会带来任何影响。</span></div><div class="line">		<span class="comment">//如果任务正在运行，那么将被中断。</span></div><div class="line">		<span class="keyword">task</span>.cancel(<span class="keyword">true</span>);</div><div class="line">	}</div><div class="line">						</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="采用ThreadPoolExecutor的newTaskFor封装非标准取消">采用ThreadPoolExecutor的newTaskFor封装非标准取消</h2>
<p>当把一个Callable提交给ExecutorService时，submit方法会返回一个Future，我们可以通过这个Future来取消任务。newTaskFor是一个工厂方法，它将创建Future来代表任务。newTaskFor还能返回一个RunnableFuture接口，该接口扩展了Future和Runnable。</p>
<p>通过定制表示任务的Future可以该表Future.cancle()行为，比如可以实现记录日志或者收集取消操作的统计信息。下面的代码介绍了通过newTaskFor将非标准的取消操作封装在一个任务中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CancellableTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt;</span>{</div><div class="line">	<span class="keyword">void</span> cancel();</div><div class="line">	RunnableFuture&lt;T&gt; newTask();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancellingExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span>{</div><div class="line">	<span class="keyword">protected</span>&lt;T&gt; RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span>(Callable&lt;T&gt; callable){</div><div class="line">		<span class="keyword">if</span>(callable <span class="keyword">instanceof</span> CancellableTask){</div><div class="line">			<span class="keyword">return</span> ((CancellableTask&lt;T&gt;) callable).newTask();</div><div class="line">		}<span class="keyword">else</span>{</div><div class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.newTaskFor(callable);</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketUsingTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">CancellableTask</span>&lt;<span class="title">T</span>&gt;</span>{</div><div class="line">	<span class="keyword">private</span> Socket socket;</div><div class="line">	</div><div class="line">	<span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSocket</span>(Socket s){</div><div class="line">		<span class="keyword">this</span>.socket = s;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cancel</span>(){</div><div class="line">		<span class="keyword">try</span>{</div><div class="line">			<span class="keyword">if</span>(socket != <span class="keyword">null</span>){</div><div class="line">				socket.close();</div><div class="line">			}</div><div class="line">		}<span class="keyword">catch</span>(IOException ignored){</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> RunnableFuture&lt;T&gt; <span class="title">newTask</span>(){</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(<span class="keyword">this</span>){</div><div class="line">			<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span>(<span class="keyword">boolean</span> mayInterruptIfRunning){</div><div class="line">				<span class="keyword">try</span>{</div><div class="line">					SocketUsingTask.<span class="keyword">this</span>.cancel():</div><div class="line">				}<span class="keyword">finally</span>{</div><div class="line">					<span class="keyword">return</span> <span class="keyword">super</span>.cancel(mayInterruptIfRunning);</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="使用ExecutorService">使用ExecutorService</h2>
<p>可以使用ExecutorService的shutdown正常关闭和shutdownNow强行关闭。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogService</span></span>{</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = Executors.newSingleThreadExecutor();</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span>(){}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span>() <span class="keyword">throws</span> InterruptedException{</div><div class="line">		<span class="keyword">try</span>{</div><div class="line">			exec.shutdown();</div><div class="line">			exec.awaitTermination(TIMEOUT, UNIT);</div><div class="line">		}<span class="keyword">finally</span>{</div><div class="line">			writer.close();</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span>(String msg){</div><div class="line">		<span class="keyword">try</span>{</div><div class="line">			exec.execute(<span class="keyword">new</span> WriteTask(msg));</div><div class="line">		}<span class="keyword">catch</span>(RejectedExecutionException ignored){</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="使用“毒丸”对象">使用“毒丸”对象</h2>
<p>“毒丸”是指一个放在队列上的对象，当得到这个对象时，立即停止。生产者提交了这个对象以后，将不会提交任何对象。而消费者在得到这个对象时，停止消费。这种方式只有在生产者和消费者的数量都已知的情况下，才可以使用。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-26T04:03:25.000Z"><a href="/2016/03/26/Unix的I-O模型与Java的I-O/">3月 26 2016</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/26/Unix的I-O模型与Java的I-O/">Unix的I/O模型</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Unix的I/O模型">Unix的I/O模型</h2>
<p>Unix内核将所有外设都看做文件来操作，对文件的读写操作会调用内核提供的系统命令，返回一个文件描述符(file descriptor)。</p>
<p>Unix提供了以下5种I/O模型：</p>
<h3 id="阻塞I/O模型">阻塞I/O模型</h3>
<p>缺省情况下，所有文件操作都是阻塞的，如下图所示，进程调用recvfrom, 系统调用知道数据报到达并且被复制到应用进程的缓冲区中或发生错误才返回，所以说进程在从调用recvfrom开始到它返回的整段时间内都是阻塞的。包括两个阶段：</p>
<ul>
<li>等待数据就绪。等待将数据(包括磁盘数据或者网络数据)读取到内核态内存中。</li>
<li>数据从内核拷贝到进程。用户态的程序没有权限直接读取内核态内存,因此内核负责把内核态内存中的数据拷贝一份到用户态内存中。</li>
</ul>
<p><img src="/img/IO/阻塞IO.png" alt="image"></p>
<h3 id="非阻塞式I/O模型">非阻塞式I/O模型</h3>
<p>非阻塞式I/O是当锁清秋的I/O操作非得把进程投入睡眠才能完成时，不要将进程睡眠，而是返回一个错误。I/O操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。整个 I/O 请求的过程中，虽然用户线程每次发起 I/O 请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的 CPU 的资源。</p>
<p><img src="/img/IO/非阻塞IO.png" alt="image"></p>
<p>当一个应用进程像这样对一个非阻塞描述字循环调用recvfrom时，我们称之为轮询（polling）。应用进程持续轮询内核，以查看某个操作是否就绪。这么做往往耗费大量CPU时间，不过这种模型偶尔也会遇到，通常是在只专门提供某种功能的系统中才有。</p>
<h3 id="I/O复用模型">I/O复用模型</h3>
<p>I/O复用模型会用到select或者poll函数，进程通过将一个或者多个fd传递给select或poll系统调用，阻塞的是在这两个系统调用中的某一个之上，而不是阻塞在真正的I/O系统调用上，这样select/poll可以帮我们探测多个fd是否处于就绪状态。</p>
<p>select/poll顺序扫描fd是否就绪，而且支持的fd数量有限，因此使用受到了一定制约，linux还提供了一个epoll系统调用，epoll使用基于事件驱动方式代替顺序扫描，因此性能更高，当有fd就绪时，立即回调函数rollback。</p>
<p><img src="/img/IO/IO复用.png" alt="image"></p>
<h3 id="信号I/O驱动模型">信号I/O驱动模型</h3>
<p>该模型使用信号，让内核在描述字就绪时发送SIGIO信号通知我们。我们称这种模型为信号驱动I/O(signal-driven I/O)。</p>
<p><img src="/img/IO/信号驱动IO.png" alt="image"></p>
<p>首先开启套接字的信号驱动式I/O功能，并通过sigaction系统调用安装一个信号处理函数，该系统调用将立即返回(非阻塞)。当数据就绪时，为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主循环函数处理数据。</p>
<h3 id="异步I/O模型">异步I/O模型</h3>
<p>告知内核启动某个操作，并让内核在整个操作完成后通知我们，这种模型与信号驱动模型的主要区别是:</p>
<ul>
<li>信号驱动I/O由内核通知我们何时可以开始一个I/O操作。</li>
<li>异步I/O由内核通知我们I/O操作何时完成。</li>
</ul>
<p><img src="/img/IO/异步IO.png" alt="image"></p>
<h2 id="参考文献">参考文献</h2>
<ol>
<li>UNIX网络编程</li>
<li>Netty权威指南</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-24T08:38:29.000Z"><a href="/2016/03/24/如何获取一个Java对象占用内存大小/">3月 24 2016</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/24/如何获取一个Java对象占用内存大小/">如何获取一个Java对象占用内存大小</a></h1>
  

    </header>
    <div class="entry">
      
        <p>这几天在准备面试，把《深入理解Java虚拟机》，《深入分析Java Web》这两本书又翻了一遍，回顾了一些关于JVM内存划分相关的知识，但是对于如何判断Java对象内存大小并没有什么思路，于是在网上找到了一篇神文：<a href="http://www.jroller.com/maxim/entry/again_about_determining_size_of" target="_blank" rel="external">Again about determining size of Java object
</a> ，里面提供了一种采用Java Instrumentation计算Java对象内存大小的方法。</p>
<h2 id="几种不同的计算Java内存大小的方式">几种不同的计算Java内存大小的方式</h2>
<ul>
<li><a href="http://jroller.com/mipsJava/entry/sizeof_java_objects" target="_blank" rel="external">http://jroller.com/mipsJava/entry/sizeof_java_objects</a>提供了一种很巧妙的方法，采用System.gc(),Runtime.freeMemory()和Runtime.totalMemory(), 先创建大量的对象，然后分别比较GC前后heap的大小，就可以计算出每个对象所占内存大小。</li>
<li>估算所有primitive type的大小来估算对象大小。</li>
<li>使用Instrumentation.getObjectSize()方法。</li>
</ul>
<h2 id="使用Instrumentation_API计算内存大小">使用Instrumentation API计算内存大小</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Array;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</div><div class="line"><span class="keyword">import</span> java.util.IdentityHashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SizeOfAgent</span> </span>{</div><div class="line"></div><div class="line">    <span class="keyword">static</span> Instrumentation inst;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span>(String agentArgs, Instrumentation instP) {</div><div class="line">        inst = instP;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line">     * 直接计算当前对象占用空间大小，包括当前类及超类的基本类型实例字段大小、&lt;/br&gt;</div><div class="line">     * 引用类型实例字段引用大小、实例基本类型数组总占用空间、实例引用类型数组引用本身占用空间大小;&lt;/br&gt;</div><div class="line">     * 但是不包括超类继承下来的和当前类声明的实例引用字段的对象本身的大小、实例引用数组引用的对象本身的大小 &lt;/br&gt;</div><div class="line">     * 具体结果和JVM不同实现有关.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sizeOf</span>(Object o) {</div><div class="line">        <span class="keyword">if</span> (inst == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not access instrumentation environment.\n"</span> +</div><div class="line">                    <span class="string">"Please check if jar file containing SizeOfAgent class is \n"</span> +</div><div class="line">                    <span class="string">"specified in the java's \"-javaagent\" command line argument."</span>);</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> inst.getObjectSize(o);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line">     * Calculates full size of object iterating over its hierarchy graph.</div><div class="line">     *<span class="javadoctag"> @param</span> obj object to calculate size of</div><div class="line">     *<span class="javadoctag"> @return</span> object size</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fullSizeOf</span>(Object obj) {</div><div class="line">        Map&lt;Object, Object&gt; visited = <span class="keyword">new</span> IdentityHashMap&lt;Object, Object&gt;();</div><div class="line">        Stack&lt;Object&gt; stack = <span class="keyword">new</span> Stack&lt;Object&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">long</span> result = internalSizeOf(obj, stack, visited);</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</div><div class="line">            result += internalSizeOf(stack.pop(), stack, visited);</div><div class="line">        }</div><div class="line">        visited.clear();</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">skipObject</span>(Object obj, Map&lt;Object, Object&gt; visited) {</div><div class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) {</div><div class="line">            <span class="comment">// skip interned string</span></div><div class="line">            <span class="keyword">if</span> (obj == ((String) obj).intern()) {</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> (obj == <span class="keyword">null</span>) <span class="comment">// skip visited object</span></div><div class="line">                || visited.containsKey(obj);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">internalSizeOf</span>(Object obj, Stack&lt;Object&gt; stack, Map&lt;Object, Object&gt; visited) {</div><div class="line">        <span class="keyword">if</span> (skipObject(obj, visited)) {</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        }</div><div class="line">        visited.put(obj, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</div><div class="line">        <span class="comment">// get size of object + primitive variables + member pointers</span></div><div class="line">        result += SizeOfAgent.sizeOf(obj);</div><div class="line"></div><div class="line">        <span class="comment">// process all array elements</span></div><div class="line">        Class clazz = obj.getClass();</div><div class="line">        <span class="keyword">if</span> (clazz.isArray()) {</div><div class="line">            <span class="keyword">if</span> (clazz.getName().length() != <span class="number">2</span>) {<span class="comment">// skip primitive type array</span></div><div class="line">                <span class="keyword">int</span> length = Array.getLength(obj);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</div><div class="line">                    stack.add(Array.get(obj, i));</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// process all fields of the object</span></div><div class="line">        <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) {</div><div class="line">            Field[] fields = clazz.getDeclaredFields();</div><div class="line">            <span class="keyword">for</span> (Field field : fields) {</div><div class="line">                <span class="keyword">if</span> (!Modifier.isStatic(field.getModifiers())) {</div><div class="line">                    <span class="keyword">if</span> (field.getType().isPrimitive()) {</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    } <span class="keyword">else</span> {</div><div class="line">                        field.setAccessible(<span class="keyword">true</span>);</div><div class="line">                        <span class="keyword">try</span> {</div><div class="line">                            <span class="comment">// objects to be estimated are put to stack</span></div><div class="line">                            Object objectToAdd = field.get(obj);</div><div class="line">                            <span class="keyword">if</span> (objectToAdd != <span class="keyword">null</span>) {</div><div class="line">                                stack.add(objectToAdd);</div><div class="line">                            }</div><div class="line">                        } <span class="keyword">catch</span> (IllegalAccessException ex) {</div><div class="line">                            <span class="keyword">assert</span> <span class="keyword">false</span>;</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">            clazz = clazz.getSuperclass();</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-24T07:38:29.000Z"><a href="/2016/03/24/Least Recently Used(LRU)缓存/">3月 24 2016</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/24/Least Recently Used(LRU)缓存/">Least Recently Used(LRU)缓存</a></h1>
  

    </header>
    <div class="entry">
      
        <p>LRU是Least Recently Used 的缩写，翻译过来就是“最近最少使用”，LRU缓存就是使用这种原理实现，简单的说就是缓存一定量的数据，当超过设定的阈值时就把一些过期的数据删除掉。可以被用来作为手机通话记录，最近接打的电话再最前面，超过一定数目了就删掉。有两种实现方法：</p>
<h2 id="组合LinkedHashMap">组合LinkedHashMap</h2>
<p>LinkedHashMap实现了顺序存储，默认情况下是按照元素的添加顺序存储，也可以启用按照访问顺序存储,同时它还有一个判断是否删除最老数据的方法，默认是返回false，即不删除数据：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="title">LinkedHashMap</span>(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder){</div><div class="line">     <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">     <span class="keyword">this</span>.accessOrder = accessOrder;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span>(Map.Entry&lt;K,V&gt; eldest) {</div><div class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们可以直接组合LinkedHashMap，调用构造器时将accessOrder设置为true，也就是按照访问顺序存储，同时override removeEldestEntry方法使其返回true，就可以非常方便的就可以实现这个数据结构。下面是实现代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CACHE_SIZE;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75</span>f;</div><div class="line">    <span class="keyword">private</span> LinkedHashMap&lt;K, V&gt; map;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">LRUCache</span>(<span class="keyword">int</span> maxCacheSize) {</div><div class="line">        <span class="keyword">this</span>.MAX_CACHE_SIZE = maxCacheSize;</div><div class="line">        <span class="keyword">int</span> capacity = (<span class="keyword">int</span>) Math.ceil(MAX_CACHE_SIZE / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>;</div><div class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(capacity, DEFAULT_LOAD_FACTOR, <span class="keyword">true</span>) {</div><div class="line">            <span class="annotation">@Override</span></div><div class="line">            <span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span>(Entry eldest) {</div><div class="line">                <span class="keyword">return</span> size() &gt; MAX_CACHE_SIZE;</div><div class="line">            }</div><div class="line">        };</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(K key, V value) {</div><div class="line">        map.put(key, value);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> V <span class="title">get</span>(K key) {</div><div class="line">        <span class="keyword">return</span> map.get(key);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>(K key) {</div><div class="line">        map.remove(key);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Set&lt;Entry&lt;K, V&gt;&gt; <span class="title">getAll</span>() {</div><div class="line">        <span class="keyword">return</span> map.entrySet();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>() {</div><div class="line">        <span class="keyword">return</span> map.size();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span>() {</div><div class="line">        map.clear();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> String <span class="title">toString</span>() {</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span> (Map.Entry entry : map.entrySet()) {</div><div class="line">            sb.append(String.format(<span class="string">"%s:%s "</span>, entry.getKey(), entry.getValue()));</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="HashMap加上链表实现">HashMap加上链表实现</h2>
<p>HashMap可以实现get()方法的O(1)时间复杂度，添加和删除需要维护一条双向链表来记录节点顺序同时也可以达到O(1)时间复杂度。</p>
<p><img src="/img/LRUCache.png" alt="image"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> LRUCache {</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> HashMap&lt;Integer, DoubleLinkedNode&gt; nodeMap;</div><div class="line">    <span class="keyword">private</span> DoubleLinkedNode head;</div><div class="line">    <span class="keyword">private</span> DoubleLinkedNode end;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">LRUCache</span>(<span class="keyword">int</span> capacity) {</div><div class="line">        nodeMap = <span class="keyword">new</span> HashMap&lt;&gt;(capacity);</div><div class="line">        <span class="keyword">this</span>.capacity = capacity;</div><div class="line">        <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span>(<span class="keyword">int</span> key) {</div><div class="line">        DoubleLinkedNode node = nodeMap.<span class="keyword">get</span>(key);</div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) {</div><div class="line">            moveToHead(node);</div><div class="line">            <span class="keyword">return</span> node.<span class="keyword">value</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> <span class="keyword">value</span>) {</div><div class="line">        <span class="keyword">if</span> (nodeMap.containsKey(key)) {</div><div class="line">            DoubleLinkedNode node = nodeMap.<span class="keyword">get</span>(key);</div><div class="line">            node.<span class="keyword">value</span> = <span class="keyword">value</span>;</div><div class="line">            moveToHead(node);</div><div class="line">            nodeMap.put(key, node);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            DoubleLinkedNode newNode = <span class="keyword">new</span> DoubleLinkedNode(key, <span class="keyword">value</span>);</div><div class="line">            <span class="keyword">if</span> (capacity &lt;= length) {</div><div class="line">                removeEnd();</div><div class="line">                length--;</div><div class="line">            }</div><div class="line">            nodeMap.put(key, newNode);</div><div class="line">            moveToHead(newNode);</div><div class="line">            length++;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeEnd</span>() {</div><div class="line">        <span class="keyword">if</span>(end != <span class="keyword">null</span>){</div><div class="line">            <span class="keyword">if</span>(end.pre != <span class="keyword">null</span>){</div><div class="line">                end.pre.next = <span class="keyword">null</span>;</div><div class="line">            }<span class="keyword">else</span>{</div><div class="line">                head = <span class="keyword">null</span>;</div><div class="line">            }</div><div class="line">            nodeMap.remove(end.key);</div><div class="line">            end = end.pre;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span>(DoubleLinkedNode node) {</div><div class="line">        <span class="keyword">if</span>(node == head){</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span>(node.pre != <span class="keyword">null</span>){</div><div class="line">            node.pre.next = node.next;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span>(node.next != <span class="keyword">null</span>){</div><div class="line">            node.next.pre = node.pre;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span>(end == node){</div><div class="line">           end = node.pre;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span>(head != <span class="keyword">null</span>){</div><div class="line">            node.next = head;</div><div class="line">            head.pre = node;</div><div class="line">        }</div><div class="line">        head = node;</div><div class="line">        node.pre = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(end == <span class="keyword">null</span>){</div><div class="line">            end = head;</div><div class="line">    	}</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">class</span> DoubleLinkedNode {</div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> key;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">value</span>;</div><div class="line">        <span class="keyword">public</span> DoubleLinkedNode pre;</div><div class="line">        <span class="keyword">public</span> DoubleLinkedNode next;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="title">DoubleLinkedNode</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> <span class="keyword">value</span>) {</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Guava_Cache">Guava Cache</h2>
<p>如果在工作中还是不推荐这种造轮子方式，Guava已经为我们提供了强大的Cache功能，支持如果缓存中已经存在就直接返回，否则按照构造方式获取这个值，并放入到缓存中。并且Guava提供了Callable callback方式创建。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-23T06:38:29.000Z"><a href="/2016/03/23/Java泛型擦除与synthetic方法/">3月 23 2016</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/23/Java泛型擦除与synthetic方法/">Java泛型擦除与Synthetic方法</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Java泛型擦除">Java泛型擦除</h2>
<p>关于Java泛型与C++泛型比较这里不再讨论，直接来看Java例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> GenericDemo&lt;T&gt; {</div><div class="line">    <span class="keyword">private</span> T <span class="keyword">value</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">public</span> T <span class="title">getValue</span>() {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(T <span class="keyword">value</span>) {</div><div class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面是经过javap -c -p GenericDemo.class 反编译以后的文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> generic.GenericDemo&lt;T&gt; {</div><div class="line">  <span class="keyword">private</span> T <span class="keyword">value</span>;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> generic.<span class="title">GenericDemo</span>();</div><div class="line">    Code:</div><div class="line">       <span class="number">0</span>: aload_0       </div><div class="line">       <span class="number">1</span>: invokespecial <span class="preprocessor">#1                  // Method java/lang/Object."&lt;init&gt;":()V</span></div><div class="line">       <span class="number">4</span>: <span class="keyword">return</span>        </div><div class="line"></div><div class="line">  <span class="keyword">public</span> T <span class="title">getValue</span>();</div><div class="line">    Code:</div><div class="line">       <span class="number">0</span>: aload_0       </div><div class="line">       <span class="number">1</span>: getfield      <span class="preprocessor">#2                  // Field value:Ljava/lang/Object;</span></div><div class="line">       <span class="number">4</span>: areturn       </div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(T);</div><div class="line">    Code:</div><div class="line">       <span class="number">0</span>: aload_0       </div><div class="line">       <span class="number">1</span>: aload_1       </div><div class="line">       <span class="number">2</span>: putfield      <span class="preprocessor">#2                  // Field value:Ljava/lang/Object;</span></div><div class="line">       <span class="number">5</span>: <span class="keyword">return</span>        </div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看出javac已经将value的类型T编译为了Object类型。</p>
<h2 id="Synthetic方法与方法Override">Synthetic方法与方法Override</h2>
<p>我们为上文中的GenericDemo写一个子类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">GenericDemo</span>&lt;<span class="title">String</span>&gt; </span>{</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String value;</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> String <span class="title">getValue</span>() {</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(String value) {</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>子类A override了父类的getValue()与setValue()方法，那么问题来了，子类的setValue(String value)的参数类型为String， 而父类经过泛型擦除以后为Object，参数类型不同又为何可以override。</p>
<p>这里再提一个问题，A.class.getDeclaredMethods()有几个？</p>
<p>根据Jdk对于getDeclaredMethods()文档，getDeclaredMethods()是不包括继承的方法的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Returns an <span class="keyword">array</span> containing Method objects reflecting all the declared methods <span class="keyword">of</span> the <span class="keyword">class</span> <span class="keyword">or</span> <span class="keyword">interface</span> represented by this <span class="keyword">Class</span> <span class="keyword">object</span>, including <span class="keyword">public</span>, <span class="keyword">protected</span>, <span class="keyword">default</span> (package) access, <span class="keyword">and</span> <span class="keyword">private</span> methods, but excluding <span class="keyword">inherited</span> methods.</div></pre></td></tr></table></figure>

<p>那么这里应该返回2才对，但实际却返回了4:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> java.lang.Object generic.A.<span class="title">getValue</span>() <span class="keyword">is</span> synthetic : <span class="keyword">true</span></div><div class="line"><span class="keyword">public</span> java.lang.String generic.A.<span class="title">getValue</span>() <span class="keyword">is</span> synthetic : <span class="keyword">false</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> generic.A.<span class="title">setValue</span>(java.lang.String) <span class="keyword">is</span> synthetic : <span class="keyword">false</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> generic.A.<span class="title">setValue</span>(java.lang.Object) <span class="keyword">is</span> synthetic : <span class="keyword">true</span></div></pre></td></tr></table></figure>

<p>可以看出这里多了个两个方法，并且我多打印了一个属性synthetic。synthetic意思是合成的，这里为什么会多生成两个get和set方法?还是回到泛型中来，因为要实现override，这时编译器自动生成了两个方法来进行类型转换，下面是反编译后代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(java.lang.String);</div><div class="line">  Code:</div><div class="line">     <span class="number">0</span>: aload_0       </div><div class="line">     <span class="number">1</span>: aload_1       </div><div class="line">     <span class="number">2</span>: putfield      <span class="preprocessor">#2                  // Field value:Ljava/lang/String;</span></div><div class="line">     <span class="number">5</span>: <span class="keyword">return</span>    </div><div class="line"> </div><div class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(java.lang.Object);</div><div class="line">  Code:</div><div class="line">     <span class="number">0</span>: aload_0       </div><div class="line">     <span class="number">1</span>: aload_1       </div><div class="line">     <span class="number">2</span>: checkcast     <span class="preprocessor">#15                 // class java/lang/String</span></div><div class="line">     <span class="number">5</span>: invokevirtual <span class="preprocessor">#16                 // Method setValue:(Ljava/lang/String;)V</span></div><div class="line">     <span class="number">8</span>: <span class="keyword">return</span></div></pre></td></tr></table></figure>

<p>可以看到第二个setValue(Object)方法，先将object转换为String, 然后再去调用setValue(String)方法。</p>
<p>关于Synthetic方法，更多的可以参考：<a href="http://stackoverflow.com/questions/289731/what-java-lang-reflect-method-isbridge-used-for" target="_blank" rel="external">http://stackoverflow.com/questions/289731/what-java-lang-reflect-method-isbridge-used-for</a></p>
<h2 id="Synthetic方法与继承">Synthetic方法与继承</h2>
<p>关于Synthetic方法，并不一定是只在泛型擦除时候出现,来看下面一种情况：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class <span class="type">Parent</span> {</div><div class="line">    <span class="type">void</span> <span class="keyword">method</span>(){}</div><div class="line">}</div><div class="line"></div><div class="line">public class <span class="type">Son</span> extends <span class="type">Parent</span> {</div><div class="line">    public <span class="type">void</span> methodB(){</div><div class="line">        super.<span class="keyword">method</span>();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>有一个包级别可见的类Parent，子类Son继承父类，并作为代理将父类提供给外界使用，这时查看Son的binary code:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Compiled from <span class="string">"Son.java"</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">generic</span>.<span class="title">Son</span> <span class="keyword">extends</span> <span class="title">generic</span>.<span class="title">Parent</span> </span>{</div><div class="line">  <span class="keyword">public</span> generic.<span class="title">Son</span>();</div><div class="line">    Code:</div><div class="line">       <span class="number">0</span>: aload_0       </div><div class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method generic/Parent."&lt;init&gt;":()V</span></div><div class="line">       <span class="number">4</span>: <span class="keyword">return</span>        </div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span>();</div><div class="line">    Code:</div><div class="line">       <span class="number">0</span>: aload_0       </div><div class="line">       <span class="number">1</span>: invokespecial #<span class="number">2</span>                  <span class="comment">// Method generic/Parent.method:()V</span></div><div class="line">       <span class="number">4</span>: <span class="keyword">return</span>        </div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span>();</div><div class="line">    Code:</div><div class="line">       <span class="number">0</span>: aload_0       </div><div class="line">       <span class="number">1</span>: invokespecial #<span class="number">2</span>                  <span class="comment">// Method generic/Parent.method:()V</span></div><div class="line">       <span class="number">4</span>: <span class="keyword">return</span>        </div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到method方法也在Son中被生成了，这也是一个Synthetic方法。</p>
<h2 id="Synthetic方法与AOP">Synthetic方法与AOP</h2>
<p>有使用过Guice作为DI容器，以及进行AOP时候，会发现Guice有时会抛出warning:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">The</span> <span class="keyword">method</span> may be intercepted twice.</div></pre></td></tr></table></figure>

<p>这就是由于Synthetic方法导致的，应该是Guice的一个bug。一种解决方案就是在绑定intercepter时候配置一个相应的Matcher:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NoSyntheticMethodMatcher</span> <span class="keyword">extends</span> <span class="title">AbstractMatcher</span>&lt;<span class="title">Method</span>&gt; </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> NoSyntheticMethodMatcher INSTANCE = <span class="keyword">new</span> NoSyntheticMethodMatcher();</div><div class="line">    <span class="keyword">private</span> <span class="title">NoSyntheticMethodMatcher</span>() {}</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span>(Method method) {</div><div class="line">        <span class="keyword">return</span> !method.isSynthetic();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>只有不是synthetic的方法才进行拦截。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-22T09:38:29.000Z"><a href="/2016/03/22/JUC锁概览/">3月 22 2016</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/22/JUC锁概览/">JUC锁概览</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="JUC包中锁的类图">JUC包中锁的类图</h2>
<p><img src="/img/Lock.jpg" alt="alt Lock类图"></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-22T09:25:15.000Z"><a href="/2016/03/22/LockSupport类解析/">3月 22 2016</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/22/LockSupport类解析/">LockSupport类解析</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="LockSupport介绍">LockSupport介绍</h2>
<p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语，它可以在线程内任意位置让线程阻塞。</p>
<ul>
<li>和Thread.suspend()相比，它避免了有可能产生的死锁问题。</li>
<li>和Object.wait()相比，它不需要获得对象锁，也不会抛出InterruptedException。</li>
</ul>
<h2 id="Thread的suspend和resume方法">Thread的suspend和resume方法</h2>
<p>Thread类提供了suspend和resume方法挂起与继续执行线程，看上去这对操作非常又用，但却又被标记为deprecated，不推介使用，这是为什么呢？</p>
<p>先来阅读Jdk doc：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="type">This</span> <span class="keyword">method</span> has been deprecated, <span class="keyword">as</span> it <span class="keyword">is</span> inherently deadlock-prone. <span class="type">If</span> the target</div><div class="line">thread holds a lock on the monitor protecting a critical system resource <span class="keyword">when</span> it <span class="keyword">is</span></div><div class="line">suspended, no thread can access this resource until the target thread <span class="keyword">is</span> resumed.</div><div class="line"><span class="type">If</span> the thread that would resume the target thread attempts to lock this monitor</div><div class="line">prior to calling resume, deadlock results. <span class="type">Such</span> deadlocks typically manifest</div><div class="line">themselves <span class="keyword">as</span> <span class="string">"frozen"</span> processes.</div></pre></td></tr></table></figure>

<p>因为这对操作容易产生死锁，在suspend调用后，并不会释放锁资源，其他任何线程都无法访问锁直至这个线程被回复。但是，如果resume操作优先于suspend被执行，那么被挂起的线程就不会再被恢复，锁占有的锁也不会释放，从而导致死锁。</p>
<p>我们通过一段代码来展示这种情况:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspendDemo</span></span>{</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object u = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspendDemoThread</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">Thread</span></span>{</div><div class="line"></div><div class="line">        <span class="keyword">public</span> SuspendDemoThread(String name) {</div><div class="line">            <span class="keyword">super</span>(name);</div><div class="line">        }</div><div class="line"></div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> run() {</div><div class="line">            synchronized (u){</div><div class="line">                System.out.println(<span class="string">"Thread : "</span> + <span class="keyword">this</span>.getName() + <span class="string">" is running!"</span>);</div><div class="line">                suspend();</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws InterruptedException {</div><div class="line">        <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> SuspendDemoThread(<span class="string">"t1"</span>);</div><div class="line">        <span class="keyword">final</span> Thread t2 = <span class="keyword">new</span> SuspendDemoThread(<span class="string">"t2"</span>);</div><div class="line"></div><div class="line">        t1.start();</div><div class="line">        Thread.sleep(<span class="number">100</span>);</div><div class="line">        t2.start();</div><div class="line">        t1.resume();</div><div class="line">        t2.resume();</div><div class="line">        t1.join();</div><div class="line">        t2.join();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在IDE里运行这段代码，有可能导致线程被挂起，这时我们通过jstack查看线程情况：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="string">"t2"</span> <span class="comment">#11 prio=5 os_prio=31 tid=0x00007f9d34048800 nid=0x5103 runnable [0x000070000134f000]</span></div><div class="line">   java.lang.Thread.State: RUNNABLE</div><div class="line">	<span class="keyword">at</span> java.lang.Thread.suspend0(Native Method)</div><div class="line">	<span class="keyword">at</span> java.lang.Thread.suspend(Thread.java:<span class="number">1029</span>)</div><div class="line">	<span class="keyword">at</span> thread.SuspendDemo$ChangeObjectThread.run(SuspendDemo.java:<span class="number">20</span>)</div><div class="line">	- locked &lt;<span class="number">0x00000007957b6f98</span>&gt; (<span class="operator">a</span> java.lang.Object)</div><div class="line">	</div><div class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=31 tid=0x00007fe841011000 nid=0x1703 in Object.wait() [0x0000700000218000]</span></div><div class="line">   java.lang.Thread.State: WAITING (<span class="command"><span class="keyword">on</span> <span class="title">object</span> <span class="title">monitor</span>)</span></div><div class="line">	<span class="keyword">at</span> java.lang.Object.<span class="built_in">wait</span>(Native Method)</div><div class="line">	- waiting <span class="command"><span class="keyword">on</span> &lt;<span class="title">0x00000007957bdf98</span>&gt; (<span class="title">a</span> <span class="title">thread</span>.<span class="title">SuspendDemo</span>$<span class="title">SuspendDemoThread</span>)</span></div><div class="line">	<span class="keyword">at</span> java.lang.Thread.join(Thread.java:<span class="number">1245</span>)</div><div class="line">	- locked &lt;<span class="number">0x00000007957bdf98</span>&gt; (<span class="operator">a</span> thread.SuspendDemo$SuspendDemoThread)</div><div class="line">	<span class="keyword">at</span> java.lang.Thread.join(Thread.java:<span class="number">1319</span>)</div><div class="line">	<span class="keyword">at</span> thread.SuspendDemo.main(SuspendDemo.java:<span class="number">37</span>)</div><div class="line">	<span class="keyword">at</span> sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">	<span class="keyword">at</span> sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</div><div class="line">	<span class="keyword">at</span> sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</div><div class="line">	<span class="keyword">at</span> java.lang.reflect.Method.invoke(Method.java:<span class="number">497</span>)</div><div class="line">	<span class="keyword">at</span> com.intellij.rt.execution.application.AppMain.main(AppMain.java:<span class="number">144</span>)</div></pre></td></tr></table></figure>

<p>发现t2处于runnable状态，而不是waiting状态，并且占有了对象锁,而这时主线程main在等待t2结束，这不利于我们判断问题发生原因。</p>
<h2 id="LockSupport阻塞操作">LockSupport阻塞操作</h2>
<p>下面我们使用LockSupport来重写上面的程序:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspendDemo</span> </span>{</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object u = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspendDemoThread</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">Thread</span></span>{</div><div class="line"></div><div class="line">        <span class="keyword">public</span> SuspendDemoThread(String name) {</div><div class="line">            <span class="keyword">super</span>(name);</div><div class="line">        }</div><div class="line"></div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> run() {</div><div class="line">            synchronized (u){</div><div class="line">                System.out.println(<span class="string">"Thread : "</span> + <span class="keyword">this</span>.getName() + <span class="string">" is running!"</span>);</div><div class="line">                LockSupport.park();</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws InterruptedException {</div><div class="line">        <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> SuspendDemoThread(<span class="string">"t1"</span>);</div><div class="line">        <span class="keyword">final</span> Thread t2 = <span class="keyword">new</span> SuspendDemoThread(<span class="string">"t2"</span>);</div><div class="line"></div><div class="line">        t1.start();</div><div class="line">        Thread.sleep(<span class="number">100</span>);</div><div class="line">        t2.start();</div><div class="line">        LockSupport.unpark(t1);</div><div class="line">        LockSupport.unpark(t2);</div><div class="line">        t1.join();</div><div class="line">        t2.join();</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>将suspend和resume替换为park与unpark，这时发现这段代码一直都可以正常借宿，不会导致线程被永久挂起。这是因为LockSupport类采用类似于信号量的机制，它为每一个线程准备了一个许可，如果这个许可可用，那么park()方法会立即返回，并且消费这个许可；如果这个许可不可用，就会阻塞。而unpark()则使得一个许可变为可用。这样使得，即使unpark()操作发生在park()之前，它也可以使下一次的park()操作立刻返回。因此不会像suspend和resume这样导致线程挂起。</p>
<p>调用park()方法会使得线程处于waiting状态。</p>
<h2 id="LockSupport函数列表">LockSupport函数列表</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回提供给最近一次尚未解除阻塞的 park 方法调用的 blocker 对象，如果该调用不受阻塞，则返回 null。</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">Object</span> getBlocker(Thread t)</div><div class="line"><span class="comment">// 为了线程调度，禁用当前线程，除非许可可用。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> park()</div><div class="line"><span class="comment">// 为了线程调度，在许可可用之前禁用当前线程。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> park(<span class="built_in">Object</span> blocker)</div><div class="line"><span class="comment">// 为了线程调度禁用当前线程，最多等待指定的等待时间，除非许可可用。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> parkNanos(<span class="keyword">long</span> nanos)</div><div class="line"><span class="comment">// 为了线程调度，在许可可用前禁用当前线程，并最多等待指定的等待时间。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> parkNanos(<span class="built_in">Object</span> blocker, <span class="keyword">long</span> nanos)</div><div class="line"><span class="comment">// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> parkUntil(<span class="keyword">long</span> deadline)</div><div class="line"><span class="comment">// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> parkUntil(<span class="built_in">Object</span> blocker, <span class="keyword">long</span> deadline)</div><div class="line"><span class="comment">// 如果给定线程的许可尚不可用，则使其可用。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> unpark(Thread thread)</div></pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-21T17:03:19.000Z"><a href="/2016/03/22/JUC源码解析-基于JDK1-8/">3月 22 2016</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/22/JUC源码解析-基于JDK1-8/">JUC源码解析-基于JDK1.8</a></h1>
  

    </header>
    <div class="entry">
      
        <p>一直都想写点什么，也算是对自己工作学习的记录与反思，也算是为了未来心仪工作的一点准备，却又一直不知道写点什么。</p>
<p>最近一直在看JDK的源码，发现网上大部分的都是基于1.5或者1.6，Oracle已经正式发布JDK1.8，因此决定基于1.8版本来写点JDK源码分析，包括Collection相关类和JUC包。</p>
<p>本文是关于JUC源码解析的目录：</p>
<p><a href="http://whujl.github.io/2016/03/22/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">1. ReentrantLock源码解析</a></p>
<p>未完待续…</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Categories</h3>
  <ul class="entry">
  
    <li><a href="/categories/Core-Java/">Core Java</a><small>0</small></li>
  
    <li><a href="/categories/Data-Structure/">Data Structure</a><small>1</small></li>
  
    <li><a href="/categories/Eclipse-Plugin-Development/">Eclipse Plugin Development</a><small>1</small></li>
  
    <li><a href="/categories/HTTP/">HTTP</a><small>1</small></li>
  
    <li><a href="/categories/JUC源码分析/">JUC源码分析</a><small>3</small></li>
  
    <li><a href="/categories/JUC源码解析/">JUC源码解析</a><small>2</small></li>
  
    <li><a href="/categories/Java/">Java</a><small>3</small></li>
  
    <li><a href="/categories/Java内存/">Java内存</a><small>1</small></li>
  
    <li><a href="/categories/java/">java</a><small>0</small></li>
  
    <li><a href="/categories/数据结构与算法/">数据结构与算法</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">Tag Cloud</h3>
  <div class="entry">
    <a href="/tags/AST/" style="font-size: 13.33px;">AST</a><a href="/tags/Cache/" style="font-size: 13.33px;">Cache</a><a href="/tags/Eclipse-Plugin/" style="font-size: 13.33px;">Eclipse Plugin</a><a href="/tags/HTTP/" style="font-size: 13.33px;">HTTP</a><a href="/tags/HashMap/" style="font-size: 10.00px;">HashMap</a><a href="/tags/HashSet/" style="font-size: 10.00px;">HashSet</a><a href="/tags/JAVA/" style="font-size: 10.00px;">JAVA</a><a href="/tags/JUC/" style="font-size: 16.67px;">JUC</a><a href="/tags/Java/" style="font-size: 20.00px;">Java</a><a href="/tags/Java，JUC/" style="font-size: 13.33px;">Java，JUC</a><a href="/tags/Java，JUC，源码/" style="font-size: 16.67px;">Java，JUC，源码</a><a href="/tags/LRU/" style="font-size: 13.33px;">LRU</a><a href="/tags/Lock/" style="font-size: 13.33px;">Lock</a><a href="/tags/ThreadLocal/" style="font-size: 13.33px;">ThreadLocal</a><a href="/tags/Unix/" style="font-size: 13.33px;">Unix</a><a href="/tags/java/" style="font-size: 10.00px;">java</a><a href="/tags/多线程/" style="font-size: 13.33px;">多线程</a><a href="/tags/排序/" style="font-size: 13.33px;">排序</a>
  </div>
</div>


  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
<li><a href="http://zipperary.com/" title="Zippera's Blog">Zippera</a></li>
</ul>
</div>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 Jiao Long
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>